/// Tests for the NL → Racket compilation pipeline.
///
/// These verify that filesystem-op workflows generated by the NL layer
/// can be compiled to Racket scripts via the racket_executor.

use cadmus::workflow;
use cadmus::fs_types;

// ---------------------------------------------------------------------------
// Helper: compile a workflow YAML and generate a Racket script
// ---------------------------------------------------------------------------

fn compile_to_racket(yaml: &str) -> Result<String, String> {
    let def = workflow::parse_workflow(yaml)
        .map_err(|e| format!("parse: {}", e))?;
    let registry = fs_types::build_full_registry();
    let compiled = workflow::compile_workflow(&def, &registry)
        .map_err(|e| format!("compile: {}", e))?;

    let mut racket_reg = cadmus::registry::load_ops_pack_str(
        include_str!("../data/racket_ops.yaml")
    ).unwrap_or_default();
    if let Ok(facts) = cadmus::racket_strategy::load_racket_facts_from_str(
        include_str!("../data/racket_facts.yaml")
    ) {
        cadmus::racket_strategy::promote_inferred_ops(&mut racket_reg, &facts);

        // Include shell submodes so extract_shell_meta() works for subsumed ops
        let cli_yaml = include_str!("../data/macos_cli_facts.yaml");
        if let Ok(cli_pack) = serde_yaml::from_str::<cadmus::fact_pack::FactPack>(cli_yaml) {
            let cli_facts = cadmus::fact_pack::FactPackIndex::build(cli_pack);
            cadmus::racket_strategy::discover_shell_submodes(
                &mut racket_reg, &facts, &cli_facts,
            );
        }
    }
    cadmus::racket_executor::generate_racket_script(&compiled, &def, &racket_reg)
        .map_err(|e| format!("racket gen: {}", e))
}

// ---------------------------------------------------------------------------
// Happy path: the original repro case
// ---------------------------------------------------------------------------

#[test]
fn test_find_screenshot_compile() {
    let yaml = r#"
workflow: "Filter entries by name pattern in ~/Desktop"
inputs:
  path: "~/Desktop"
steps:
  - walk_tree
  - find_matching:
      pattern: "*.png"
  - sort_by: name
"#;

    let script = compile_to_racket(yaml).expect("should compile");
    assert!(script.contains("#lang racket"), "should have racket preamble");
    assert!(script.contains("shell-lines"), "should use shell-lines");
    assert!(script.contains("shell-quote"), "should use shell-quote for safety");
    assert!(script.contains("find"), "should use find command");
    assert!(script.contains("regexp"), "should use regexp for matching");
    assert!(script.contains("sort"), "should use sort");
}

#[test]
fn test_find_screenshot_nl_roundtrip() {
    use cadmus::nl;
    use cadmus::nl::dialogue::DialogueState;

    let mut state = DialogueState::new();
    let r1 = nl::process_input("find the latest screenshot on my desktop", &mut state);

    match &r1 {
        nl::NlResponse::PlanCreated { workflow_yaml, .. } => {
            assert!(workflow_yaml.contains("walk_tree") || workflow_yaml.contains("find_matching"),
                "should have walk/find: {}", workflow_yaml);
        }
        other => {
            panic!("Expected PlanCreated, got: {:?}", other);
        }
    }

    let r2 = nl::process_input("y", &mut state);
    match &r2 {
        nl::NlResponse::Approved { script } => {
            assert!(script.is_some(), "Script should be generated, but was None");
            let s = script.as_ref().unwrap();
            assert!(s.contains("#lang racket"));
            assert!(s.contains("shell-quote"), "should use shell-quote: {}", s);
        }
        other => {
            panic!("Expected Approved, got: {:?}", other);
        }
    }
}

// ---------------------------------------------------------------------------
// More NL → Racket roundtrips for common user requests
// ---------------------------------------------------------------------------

#[test]
fn test_list_dir_compiles_to_racket() {
    let yaml = r#"
workflow: "List directory"
inputs:
  path: "~/Downloads"
steps:
  - list_dir
"#;
    let script = compile_to_racket(yaml).expect("should compile");
    assert!(script.contains("ls"), "should use ls: {}", script);
    assert!(script.contains("shell-quote"), "should quote path");
}

#[test]
fn test_walk_tree_filter_compiles() {
    let yaml = r#"
workflow: "Find PDFs"
inputs:
  path: "~/Documents"
steps:
  - walk_tree
  - filter:
      pattern: "*.pdf"
"#;
    let script = compile_to_racket(yaml).expect("should compile");
    assert!(script.contains("find"), "should use find");
    assert!(script.contains("regexp"), "should use regexp for filter");
    assert!(script.contains("\\.pdf"), "should have pdf pattern");
}

#[test]
fn test_walk_tree_sort_compiles() {
    let yaml = r#"
workflow: "List sorted"
inputs:
  path: "~/Documents"
steps:
  - walk_tree
  - sort_by: name
"#;
    let script = compile_to_racket(yaml).expect("should compile");
    assert!(script.contains("find"), "should use find");
    assert!(script.contains("sort"), "should use sort");
    assert!(script.contains("string<?"), "should sort by string comparison");
}

#[test]
fn test_zip_workflow_compiles() {
    use cadmus::nl;
    use cadmus::nl::dialogue::DialogueState;

    let mut state = DialogueState::new();
    let r1 = nl::process_input("zip up everything in ~/Downloads", &mut state);
    assert!(matches!(r1, nl::NlResponse::PlanCreated { .. }));

    let r2 = nl::process_input("yes", &mut state);
    match r2 {
        nl::NlResponse::Approved { script } => {
            assert!(script.is_some(), "zip workflow should produce a script");
        }
        other => panic!("Expected Approved, got: {:?}", other),
    }
}

#[test]
fn test_find_pdfs_nl_compiles() {
    use cadmus::nl;
    use cadmus::nl::dialogue::DialogueState;

    let mut state = DialogueState::new();
    let r1 = nl::process_input("find all PDFs in ~/Documents", &mut state);
    assert!(matches!(r1, nl::NlResponse::PlanCreated { .. }));

    let r2 = nl::process_input("approve", &mut state);
    match r2 {
        nl::NlResponse::Approved { script } => {
            assert!(script.is_some(), "find PDFs should produce a script");
            let s = script.unwrap();
            assert!(s.contains("shell-quote"), "should use shell-quote: {}", s);
        }
        other => panic!("Expected Approved, got: {:?}", other),
    }
}

// ---------------------------------------------------------------------------
// Negative: unknown ops still error
// ---------------------------------------------------------------------------

#[test]
fn test_unknown_op_still_errors() {
    let yaml = r#"
workflow: "Bad workflow"
inputs:
  path: "/tmp"
steps:
  - nonexistent_op_xyz
"#;
    let def = workflow::parse_workflow(yaml).unwrap();
    let registry = fs_types::build_full_registry();
    let result = workflow::compile_workflow(&def, &registry);
    assert!(result.is_err(), "unknown op should fail compilation");
}

#[test]
fn test_filter_without_pattern_errors() {
    // filter without a pattern param should error in Racket codegen
    let yaml = r#"
workflow: "Bad filter"
inputs:
  path: "/tmp"
steps:
  - list_dir
  - filter
"#;
    // This should fail at the shell executor level (filter needs a pattern)
    // but the workflow compiler may accept it (filter is polymorphic)
    let def = workflow::parse_workflow(yaml).unwrap();
    let registry = fs_types::build_full_registry();
    match workflow::compile_workflow(&def, &registry) {
        Ok(compiled) => {
            let mut racket_reg = cadmus::registry::load_ops_pack_str(
                include_str!("../data/racket_ops.yaml")
            ).unwrap_or_default();
            if let Ok(facts) = cadmus::racket_strategy::load_racket_facts_from_str(
                include_str!("../data/racket_facts.yaml")
            ) {
                cadmus::racket_strategy::promote_inferred_ops(&mut racket_reg, &facts);
            }
            let result = cadmus::racket_executor::generate_racket_script(
                &compiled, &def, &racket_reg
            );
            assert!(result.is_err(), "filter without pattern should fail: {:?}", result);
        }
        Err(_) => {
            // Also acceptable — compile-time rejection
        }
    }
}

// ---------------------------------------------------------------------------
// Boundary: shell preamble emitted, injection safety
// ---------------------------------------------------------------------------

#[test]
fn test_shell_preamble_emitted_for_fs_ops() {
    let yaml = r#"
workflow: "List"
inputs:
  path: "/tmp"
steps:
  - list_dir
"#;
    let script = compile_to_racket(yaml).expect("should compile");
    assert!(script.contains("(define (shell-exec"), "should have shell-exec helper");
    assert!(script.contains("(define (shell-lines"), "should have shell-lines helper");
    assert!(script.contains("(define (shell-quote"), "should have shell-quote helper");
}

#[test]
fn test_injection_safe_in_racket_output() {
    let yaml = r#"
workflow: "Injection test"
inputs:
  path: "/tmp; rm -rf /"
steps:
  - list_dir
"#;
    let script = compile_to_racket(yaml).expect("should compile");
    // The dangerous path should be inside (shell-quote ...), not bare
    assert!(script.contains("shell-quote"), "must use shell-quote");
    // Should NOT have the path directly in a shell command string
    assert!(!script.contains("\"ls /tmp; rm -rf /\""),
        "path must not be inlined in shell command: {}", script);
}

#[test]
fn test_pipeline_with_prev_binding() {
    // Multi-step: walk_tree → filter → sort_by
    // Steps 2 and 3 should reference step_1 and step_2
    let yaml = r#"
workflow: "Pipeline"
inputs:
  path: "~/Documents"
steps:
  - walk_tree
  - filter:
      pattern: "*.txt"
  - sort_by: name
"#;
    let script = compile_to_racket(yaml).expect("should compile");
    assert!(script.contains("step_1"), "should have step_1 binding");
    assert!(script.contains("step_2"), "should have step_2 binding");
    assert!(script.contains("step_3"), "should have step_3 binding");
    assert!(script.contains("let*"), "multi-step should use let*");
}

#[test]
fn test_head_tail_count_in_pipeline() {
    let yaml = r#"
workflow: "Count files"
inputs:
  path: "~/Documents"
steps:
  - walk_tree
  - count
"#;
    let script = compile_to_racket(yaml).expect("should compile");
    assert!(script.contains("length"), "count in pipeline should use (length ...)");
}

#[test]
fn test_unique_in_pipeline() {
    // unique takes Seq(Line) — use a text file input
    let yaml = r#"
workflow: "Unique lines"
inputs:
  file: "data.txt"
steps:
  - read_file
  - unique
"#;
    // read_file on a .txt file gives Text, but unique needs Seq(Line)
    // This may not compile through the type system, so just test the codegen path
    // if it does compile
    if let Ok(script) = compile_to_racket(yaml) {
        assert!(script.contains("remove-duplicates") || script.contains("unique"),
            "unique should use remove-duplicates or unique: {}", script);
    }
}

#[test]
fn test_exclude_filter_in_pipeline() {
    let yaml = r#"
workflow: "Skip git"
inputs:
  path: "~/project"
steps:
  - walk_tree
  - filter:
      exclude: ".git"
"#;
    let script = compile_to_racket(yaml).expect("should compile");
    // Exclude filter should negate the match
    assert!(script.contains("not"), "exclude filter should negate: {}", script);
    assert!(script.contains("regexp-match?"), "should use regexp-match?");
}

// ===========================================================================
// Phase 2 Type Lowering: Comprehensive tests for all tiers
// ===========================================================================

// ---------------------------------------------------------------------------
// Tier 1: All 10 subsumed ops generate shell-based Racket expressions
// ---------------------------------------------------------------------------

#[test]
fn test_subsumption_list_dir_uses_shell_ls() {
    let yaml = r#"
workflow: "List"
inputs:
  path: "~/Music"
steps:
  - list_dir
"#;
    let script = compile_to_racket(yaml).expect("should compile");
    assert!(script.contains("shell-lines"), "should use shell-lines: {}", script);
    assert!(script.contains("ls"), "should use ls command: {}", script);
    assert!(script.contains("shell-quote"), "should quote path: {}", script);
}

#[test]
fn test_subsumption_walk_tree_uses_shell_find() {
    let yaml = r#"
workflow: "Walk"
inputs:
  path: "~/Documents"
steps:
  - walk_tree
"#;
    let script = compile_to_racket(yaml).expect("should compile");
    assert!(script.contains("shell-lines"), "should use shell-lines: {}", script);
    assert!(script.contains("find"), "should use find command: {}", script);
    assert!(script.contains("shell-quote"), "should quote path: {}", script);
}

#[test]
fn test_subsumption_read_file_uses_shell_cat() {
    let yaml = r#"
workflow: "Read"
inputs:
  file: "notes.txt"
steps:
  - read_file
"#;
    let script = compile_to_racket(yaml).expect("should compile");
    assert!(script.contains("shell-lines"), "should use shell-lines: {}", script);
    assert!(script.contains("cat"), "should use cat command: {}", script);
}

#[test]
fn test_subsumption_search_content_uses_shell_grep() {
    let yaml = r#"
workflow: "Search"
inputs:
  textdir: "~/Documents"
steps:
  - walk_tree
  - search_content:
      pattern: "TODO"
"#;
    let script = compile_to_racket(yaml).expect("should compile");
    assert!(script.contains("shell-lines"), "should use shell-lines: {}", script);
    assert!(script.contains("grep"), "should use grep command: {}", script);
    assert!(script.contains("TODO"), "should include search pattern: {}", script);
}

#[test]
fn test_subsumption_head_first_step_uses_shell() {
    let yaml = r#"
workflow: "Head"
inputs:
  file: "log.txt"
steps:
  - head
"#;
    let script = compile_to_racket(yaml).expect("should compile");
    assert!(script.contains("shell-lines"), "first-step head should use shell: {}", script);
    assert!(script.contains("head"), "should use head command: {}", script);
}

#[test]
fn test_subsumption_tail_first_step_uses_shell() {
    let yaml = r#"
workflow: "Tail"
inputs:
  file: "log.txt"
steps:
  - tail
"#;
    let script = compile_to_racket(yaml).expect("should compile");
    assert!(script.contains("shell-lines"), "first-step tail should use shell: {}", script);
    assert!(script.contains("tail"), "should use tail command: {}", script);
}

#[test]
fn test_subsumption_sort_by_first_step_uses_shell() {
    let yaml = r#"
workflow: "Sort"
inputs:
  path: "~/Documents"
steps:
  - list_dir
  - sort_by: name
"#;
    let script = compile_to_racket(yaml).expect("should compile");
    assert!(script.contains("sort"), "should use sort command: {}", script);
}

#[test]
fn test_subsumption_download_uses_shell_curl() {
    let yaml = r#"
workflow: "Download"
inputs:
  url: "https://example.com/data.csv"
steps:
  - download
"#;
    let script = compile_to_racket(yaml).expect("should compile");
    assert!(script.contains("shell-lines"), "should use shell-lines: {}", script);
    assert!(script.contains("curl"), "should use curl command: {}", script);
}

// ---------------------------------------------------------------------------
// Tier 2: Racket-native ops in pipeline use Racket primitives
// ---------------------------------------------------------------------------

#[test]
fn test_native_filter_in_pipeline_uses_racket_filter() {
    let yaml = r#"
workflow: "Filter in pipeline"
inputs:
  path: "~/Documents"
steps:
  - walk_tree
  - filter:
      pattern: "*.rs"
"#;
    let script = compile_to_racket(yaml).expect("should compile");
    // Step 1: shell bridge (find)
    assert!(script.contains("find"), "step 1 should use find");
    // Step 2: Racket-native filter
    assert!(script.contains("(filter (lambda"), "step 2 should use Racket filter: {}", script);
    assert!(script.contains("regexp-match?"), "should use regexp-match?: {}", script);
}

#[test]
fn test_native_sort_in_pipeline_uses_racket_sort() {
    let yaml = r#"
workflow: "Sort in pipeline"
inputs:
  path: "~/Documents"
steps:
  - walk_tree
  - sort_by: name
"#;
    let script = compile_to_racket(yaml).expect("should compile");
    // Step 2: Racket-native sort
    assert!(script.contains("(sort"), "should use Racket sort: {}", script);
    assert!(script.contains("string<?"), "should use string<? comparator: {}", script);
}

#[test]
fn test_native_count_in_pipeline_uses_length() {
    let yaml = r#"
workflow: "Count in pipeline"
inputs:
  path: "~/Documents"
steps:
  - walk_tree
  - count
"#;
    let script = compile_to_racket(yaml).expect("should compile");
    assert!(script.contains("(length"), "count in pipeline should use (length): {}", script);
}

#[test]
fn test_native_head_in_pipeline_uses_take() {
    let yaml = r#"
workflow: "Head in pipeline"
inputs:
  path: "~/Documents"
steps:
  - list_dir
  - filter:
      pattern: "*.txt"
  - head
"#;
    // head expects File(Text) not Seq — this may not type-check.
    // If it does compile, verify it uses take in pipeline.
    if let Ok(script) = compile_to_racket(yaml) {
        assert!(script.contains("(take") || script.contains("head"),
            "head in pipeline should use take or head: {}", script);
    }
}

#[test]
fn test_native_tail_in_pipeline_uses_take_right() {
    let yaml = r#"
workflow: "Tail in pipeline"
inputs:
  path: "~/Documents"
steps:
  - list_dir
  - filter:
      pattern: "*.log"
  - tail
"#;
    if let Ok(script) = compile_to_racket(yaml) {
        assert!(script.contains("(take-right") || script.contains("tail"),
            "tail in pipeline should use take-right or tail: {}", script);
    }
}

#[test]
fn test_native_unique_in_pipeline_uses_remove_duplicates() {
    let yaml = r#"
workflow: "Unique in pipeline"
inputs:
  path: "~/Documents"
steps:
  - walk_tree
  - filter:
      pattern: "*.txt"
  - sort_by: name
"#;
    let script = compile_to_racket(yaml).expect("should compile");
    // sort_by in pipeline should use Racket sort
    assert!(script.contains("(sort") || script.contains("string<?"),
        "sort_by in pipeline should use Racket sort: {}", script);
}

// ---------------------------------------------------------------------------
// Mixed pipeline: shell bridge + Racket native in same workflow
// ---------------------------------------------------------------------------

#[test]
fn test_mixed_pipeline_find_filter_sort_head() {
    let yaml = r#"
workflow: "Find recent Rust files"
inputs:
  path: "~/src"
steps:
  - walk_tree
  - filter:
      pattern: "*.rs"
  - sort_by: name
"#;
    let script = compile_to_racket(yaml).expect("should compile");
    // Step 1: shell bridge
    assert!(script.contains("find"), "step 1 should use find");
    assert!(script.contains("shell-lines"), "should have shell-lines");
    // Step 2: Racket-native filter
    assert!(script.contains("(filter (lambda"), "step 2 should use Racket filter");
    // Step 3: Racket-native sort
    assert!(script.contains("(sort"), "step 3 should use Racket sort");
    assert!(script.contains("string<?"), "should use string<?");
    // Should have let* for multi-step
    assert!(script.contains("let*"), "should use let* bindings");
    assert!(script.contains("step_3"), "should have step_3 binding");
}

// ---------------------------------------------------------------------------
// Subsumption map unit tests
// ---------------------------------------------------------------------------

#[test]
fn test_subsumption_map_completeness() {
    use cadmus::type_lowering;

    // All 10 subsumed ops should be present
    let expected = vec![
        ("list_dir", "shell_ls"),
        ("walk_tree", "shell_find"),
        ("read_file", "shell_cat"),
        ("search_content", "shell_grep"),
        ("head", "shell_head"),
        ("tail", "shell_tail"),
        ("sort_by", "shell_sort"),
        ("count", "shell_wc"),
        ("get_size", "shell_du"),
        ("download", "shell_curl"),
    ];

    for (fs_op, shell_op) in &expected {
        let entry = type_lowering::lookup_subsumption(fs_op)
            .unwrap_or_else(|| panic!("missing subsumption for {}", fs_op));
        assert_eq!(entry.shell_op, *shell_op,
            "{} should map to {}, got {}", fs_op, shell_op, entry.shell_op);
    }
}

#[test]
fn test_racket_native_map_completeness() {
    use cadmus::type_lowering;

    // Racket-native ops
    assert!(type_lowering::lookup_racket_native("filter").is_some());
    assert!(type_lowering::lookup_racket_native("find_matching").is_some());
    assert!(type_lowering::lookup_racket_native("unique").is_some());
    assert!(type_lowering::lookup_racket_native("flatten_tree").is_some());

    // Dual-behavior ops
    assert!(type_lowering::lookup_dual_behavior("head").is_some());
    assert!(type_lowering::lookup_dual_behavior("tail").is_some());
    assert!(type_lowering::lookup_dual_behavior("sort_by").is_some());
    assert!(type_lowering::lookup_dual_behavior("count").is_some());
    assert!(type_lowering::lookup_dual_behavior("unique").is_some());

    // Non-lowered ops should return None
    assert!(type_lowering::lookup_racket_native("walk_tree").is_none());
    assert!(type_lowering::lookup_dual_behavior("walk_tree").is_none());
}

#[test]
fn test_search_content_requires_pattern() {
    // Verify count and unique work in pipeline (dual behavior)
    let yaml_count = r#"
workflow: "Count files"
inputs:
  path: "~/Documents"
steps:
  - list_dir
  - count
"#;
    let script = compile_to_racket(yaml_count).expect("count should compile");
    assert!(script.contains("(length"), "count in pipeline should use length: {}", script);

    // search_content without pattern should error
    let yaml = r#"
workflow: "Search without pattern"
inputs:
  textdir: "~/Documents"
steps:
  - walk_tree
  - search_content
"#;
    let def = workflow::parse_workflow(yaml).unwrap();
    let registry = fs_types::build_full_registry();
    match workflow::compile_workflow(&def, &registry) {
        Ok(compiled) => {
            let mut racket_reg = cadmus::registry::load_ops_pack_str(
                include_str!("../data/racket_ops.yaml")
            ).unwrap_or_default();
            if let Ok(facts) = cadmus::racket_strategy::load_racket_facts_from_str(
                include_str!("../data/racket_facts.yaml")
            ) {
                cadmus::racket_strategy::promote_inferred_ops(&mut racket_reg, &facts);
            }
            let result = cadmus::racket_executor::generate_racket_script(
                &compiled, &def, &racket_reg
            );
            assert!(result.is_err(), "search_content without pattern should fail: {:?}", result);
        }
        Err(_) => {
            // Also acceptable — compile-time rejection
        }
    }
}

// ---------------------------------------------------------------------------
// Seq→String bridge integration tests
// ---------------------------------------------------------------------------

#[test]
fn test_walk_tree_pack_archive_seq_bridge() {
    // walk_tree → pack_archive: walk_tree produces List(String),
    // pack_archive should use string-join to pass all files to tar
    let yaml = r#"
workflow: "Zip up downloads"
inputs:
  path: "~/Downloads"
steps:
  - walk_tree
  - pack_archive
"#;
    let script = compile_to_racket(yaml).expect("should compile");
    // The bridge should use string-join or map shell-quote, NOT raw (shell-quote step_1)
    assert!(script.contains("string-join") || script.contains("map shell-quote"),
        "pack_archive after walk_tree should bridge via string-join:\n{}", script);
    assert!(!script.contains("(shell-quote step_1)"),
        "should NOT raw shell-quote the list variable:\n{}", script);
    // Should still have the find command for walk_tree
    assert!(script.contains("find"),
        "walk_tree should use find:\n{}", script);
}

#[test]
fn test_walk_tree_search_content_seq_bridge() {
    // walk_tree → search_content: walk_tree produces List(String),
    // search_content should iterate over each file with grep
    let yaml = r#"
workflow: "Search for TODO"
inputs:
  textdir: "~/Projects"
steps:
  - walk_tree
  - search_content:
      pattern: "TODO"
"#;
    let script = compile_to_racket(yaml).expect("should compile");
    // Should use append-map to grep each file
    assert!(script.contains("append-map"),
        "search_content after walk_tree should use append-map:\n{}", script);
    assert!(script.contains("grep"),
        "should use grep command:\n{}", script);
    assert!(!script.contains("(shell-quote step_1)"),
        "should NOT raw shell-quote the list variable:\n{}", script);
}

#[test]
fn test_three_step_walk_filter_pack() {
    // walk_tree → filter → pack_archive: filter output is still Seq,
    // so pack_archive should still get the bridge
    let yaml = r#"
workflow: "Zip PDFs"
inputs:
  path: "~/Documents"
steps:
  - walk_tree
  - filter:
      pattern: "*.pdf"
  - pack_archive
"#;
    let script = compile_to_racket(yaml).expect("should compile");
    // pack_archive (step 3) should bridge because filter (step 2) output is Seq
    assert!(script.contains("string-join") || script.contains("map shell-quote"),
        "pack_archive after filter should still bridge:\n{}", script);
    // filter should use Racket-native filter
    assert!(script.contains("(filter (lambda"),
        "filter should use Racket-native filter:\n{}", script);
}

#[test]
fn test_list_dir_single_step_no_bridge() {
    // Single-step list_dir: no bridge needed (no prev step)
    let yaml = r#"
workflow: "List downloads"
inputs:
  path: "~/Downloads"
steps:
  - list_dir
"#;
    let script = compile_to_racket(yaml).expect("should compile");
    // Should use shell-quote on the input path, not string-join
    assert!(script.contains("shell-quote"),
        "single-step list_dir should use shell-quote:\n{}", script);
    assert!(!script.contains("string-join"),
        "single-step should NOT use string-join:\n{}", script);
    assert!(!script.contains("append-map"),
        "single-step should NOT use append-map:\n{}", script);
}

#[test]
fn test_walk_tree_filter_sort_no_bridge() {
    // walk_tree → filter → sort_by: all ops handle lists natively,
    // no bridge needed (filter and sort_by are Racket-native)
    let yaml = r#"
workflow: "Find and sort PDFs"
inputs:
  path: "~/Documents"
steps:
  - walk_tree
  - find_matching:
      pattern: "*.pdf"
  - sort_by: name
"#;
    let script = compile_to_racket(yaml).expect("should compile");
    // These ops handle lists natively — no string-join or append-map
    assert!(!script.contains("string-join"),
        "native pipeline should NOT use string-join:\n{}", script);
    assert!(!script.contains("append-map"),
        "native pipeline should NOT use append-map:\n{}", script);
    // Should have find, filter, sort
    assert!(script.contains("find"), "should use find:\n{}", script);
    assert!(script.contains("(filter (lambda"), "should use Racket filter:\n{}", script);
    assert!(script.contains("(sort"), "should use Racket sort:\n{}", script);
}

#[test]
fn test_arithmetic_no_bridge() {
    // Pure Racket arithmetic: no bridge needed
    let yaml = r#"
workflow: "Add numbers"
inputs:
  x: "42"
  y: "17"
steps:
  - add:
      x: "$x"
      y: "$y"
"#;
    let script = compile_to_racket(yaml).expect("should compile");
    assert!(script.contains("(+ 42 17)"),
        "should generate (+ 42 17):\n{}", script);
    assert!(!script.contains("string-join"),
        "arithmetic should NOT use string-join:\n{}", script);
    assert!(!script.contains("append-map"),
        "arithmetic should NOT use append-map:\n{}", script);
}

#[test]
fn test_walk_tree_filter_search_content_bridge() {
    // walk_tree → filter → search_content: filter output is still Seq,
    // search_content should iterate
    let yaml = r#"
workflow: "Search Rust files for TODO"
inputs:
  textdir: "~/Projects"
steps:
  - walk_tree
  - filter:
      pattern: "*.rs"
  - search_content:
      pattern: "TODO"
"#;
    let script = compile_to_racket(yaml).expect("should compile");
    assert!(script.contains("append-map"),
        "search_content after filter should use append-map:\n{}", script);
    assert!(script.contains("grep"),
        "should use grep:\n{}", script);
}
