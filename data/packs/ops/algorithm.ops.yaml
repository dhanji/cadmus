# Algorithm Operations Pack
# =========================
# Opaque atomic operations for classic algorithms. Each op has a typed
# signature and a Racket implementation body. The executor emits the body
# as a (define ...) form and calls it by name at the step site.
#
# These ops are "library calls" — plans use them as single steps:
#   steps:
#     - quicksort
#
# The Racket body is opaque to the plan compiler. Type checking happens
# via the input/output signature, not by inspecting the body.

name: algorithm
description: "Classic algorithm implementations: sorting, searching, graph, DP, string, number theory, etc."

ops:

  # =========================================================================
  # Arithmetic
  # =========================================================================

  - name: base_conversion
    inputs: ['Number', 'Number']
    input_names: ['n', 'base']
    output: "String"
    racket_symbol: "base_conversion"
    description: "Base conversion: convert decimal to given base"
    racket_body: |
      (let loop ([x n] [acc (list)]) (if (= x 0) (if (null? acc) "0" (apply string-append (map (lambda (d) (string (integer->char (if (< d 10) (+ d 48) (+ d 55))))) acc))) (loop (quotient x base) (cons (remainder x base) acc))))

  - name: collatz_sequence
    inputs: ['Number']
    input_names: ['n']
    output: "List(Number)"
    racket_symbol: "collatz_sequence"
    description: "Collatz sequence: start at n, if even n/2, if odd 3n+1, until 1"
    racket_body: |
      (let loop ([x n] [acc (list)]) (let ([acc (append acc (list x))]) (if (= x 1) acc (loop (if (even? x) (/ x 2) (+ (* 3 x) 1)) acc))))

  - name: digital_root
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "digital_root"
    description: "Digital root: repeatedly sum digits until single digit"
    racket_body: |
      (let loop ([x n]) (if (< x 10) x (loop (for/sum ([c (in-string (number->string x))]) (- (char->integer c) 48)))))

  - name: fibonacci
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "fibonacci"
    description: "Fibonacci: F(n) where F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2)"
    racket_body: |
      (let loop ([a 0] [b 1] [i 0]) (if (= i n) a (loop b (+ a b) (+ i 1))))

  - name: integer_square_root
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "integer_square_root"
    description: "Integer square root: floor(sqrt(n)) using Newton's method"
    racket_body: |
      (let loop ([x n]) (let ([next (quotient (+ x (quotient n x)) 2)]) (if (>= next x) x (loop next))))

  - name: newton_raphson_sqrt
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "newton_raphson_sqrt"
    description: "Newton-Raphson square root approximation"
    racket_body: |
      (let loop ([x 1.0] [i 0]) (if (= i 20) x (loop (/ (+ x (/ n x)) 2.0) (+ i 1))))

  # =========================================================================
  # Bitwise
  # =========================================================================

  - name: population_count
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "population_count"
    description: "Population count: number of 1-bits in binary representation"
    racket_body: |
      (let loop ([x n] [count 0]) (if (= x 0) count (loop (arithmetic-shift x -1) (+ count (bitwise-and x 1)))))

  # =========================================================================
  # Combinatorics
  # =========================================================================

  - name: derangement_count
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "derangement_count"
    description: "Derangement count: D(n) = (n-1)(D(n-1) + D(n-2))"
    racket_body: |
      (let loop ([a 0] [b 1] [i 2]) (if (> i n) a (loop (+ (* (- i 1) (+ a b))) a (+ i 1))))

  # =========================================================================
  # Data Structures
  # =========================================================================

  - name: binary_min_heap
    inputs: ['Number']
    input_names: ['n']
    output: "List(Number)"
    racket_symbol: "binary_min_heap"
    description: "Binary min-heap: insert elements and extract-min"
    racket_body: |
      (let* ([heap (make-vector 10 0)] [size (box 0)] [swap! (lambda (i j) (let ([t (vector-ref heap i)]) (vector-set! heap i (vector-ref heap j)) (vector-set! heap j t)))] [insert! (lambda (insert! v) (let ([i (unbox size)]) (set-box! size (+ i 1)) (vector-set! heap i v) (let up ([i i]) (when (and (> i 0) (< (vector-ref heap i) (vector-ref heap (quotient (- i 1) 2)))) (swap! i (quotient (- i 1) 2)) (up (quotient (- i 1) 2))))))] [extract-min! (lambda (extract-min!) (let ([mn (vector-ref heap 0)] [last-idx (- (unbox size) 1)]) (vector-set! heap 0 (vector-ref heap last-idx)) (set-box! size last-idx) (let down ([i 0]) (let* ([l (+ (* 2 i) 1)] [r (+ (* 2 i) 2)] [smallest (if (and (< l (unbox size)) (< (vector-ref heap l) (vector-ref heap i))) l i)] [smallest (if (and (< r (unbox size)) (< (vector-ref heap r) (vector-ref heap smallest))) r smallest)]) (unless (= smallest i) (swap! i smallest) (down smallest)))) mn))]) (begin (for-each (lambda (v) (insert! insert! v)) (list 5 3 8 1 9)) (for/list ([_ (in-range 3)]) (extract-min! extract-min!))))

  - name: bloom_filter
    inputs: ['Number']
    input_names: ['n']
    output: "List(Boolean)"
    racket_symbol: "bloom_filter"
    description: "Bloom filter: probabilistic set membership (simplified)"
    racket_body: |
      (let* ([size 64] [bits (make-vector 64 #f)] [hash1 (lambda (s) (modulo (for/fold ([h 0]) ([c (in-string s)]) (+ (* h 31) (char->integer c))) 64))] [hash2 (lambda (s) (modulo (for/fold ([h 0]) ([c (in-string s)]) (+ (* h 37) (char->integer c))) 64))] [insert! (lambda (s) (vector-set! bits (hash1 s) #t) (vector-set! bits (hash2 s) #t))] [member? (lambda (s) (and (vector-ref bits (hash1 s)) (vector-ref bits (hash2 s))))]) (begin (insert! "hello") (insert! "world") (list (member? "hello") (member? "foo"))))

  - name: floyd_cycle_detection
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "floyd_cycle_detection"
    description: "Floyd's cycle detection: find cycle start in linked list"
    racket_body: |
      (let* ([next (vector 1 2 3 4 5 3)]) (let ([slow (let phase1 ([slow 0] [fast 0]) (let ([slow (vector-ref next slow)] [fast (vector-ref next (vector-ref next fast))]) (if (= slow fast) slow (phase1 slow fast))))]) (let phase2 ([a 0] [b slow]) (if (= a b) a (phase2 (vector-ref next a) (vector-ref next b))))))

  - name: lru_cache_eviction
    inputs: ['Number']
    input_names: ['n']
    output: "List(Number)"
    racket_symbol: "lru_cache_eviction"
    description: "LRU cache: simulate cache with capacity 2"
    racket_body: |
      (let* ([capacity 2]) (let loop ([ops (list 1 2 3 1)] [cache (list)]) (if (null? ops) cache (let* ([key (car ops)] [cache (remove key cache)] [cache (cons key cache)] [cache (if (> (length cache) capacity) (take cache capacity) cache)]) (loop (cdr ops) cache)))))

  - name: union_find
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "union_find"
    description: "Union-Find: count connected components after unions"
    racket_body: |
      (let* ([parent (build-vector 5 values)] [rank (make-vector 5 0)] [find (lambda (find x) (if (= (vector-ref parent x) x) x (let ([r (find find (vector-ref parent x))]) (vector-set! parent x r) r)))] [union! (lambda (find x y) (let ([rx (find find x)] [ry (find find y)]) (unless (= rx ry) (cond [(< (vector-ref rank rx) (vector-ref rank ry)) (vector-set! parent rx ry)] [(> (vector-ref rank rx) (vector-ref rank ry)) (vector-set! parent ry rx)] [else (vector-set! parent ry rx) (vector-set! rank rx (+ (vector-ref rank rx) 1))]))))]) (begin (union! find 0 1) (union! find 2 3) (union! find 0 2) (length (remove-duplicates (for/list ([i (in-range n)]) (find find i))))))

  # =========================================================================
  # Dynamic Programming
  # =========================================================================

  - name: climbing_stairs
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "climbing_stairs"
    description: "Climbing stairs: ways to climb n stairs (1 or 2 steps at a time)"
    racket_body: |
      (let loop ([a 1] [b 1] [i 2]) (if (> i n) b (loop b (+ a b) (+ i 1))))

  - name: kadanes_maximum_subarray
    inputs: ['List(Number)']
    input_names: ['lst']
    output: "Number"
    racket_symbol: "kadanes_maximum_subarray"
    description: "Kadane's algorithm: maximum subarray sum"
    racket_body: |
      (let loop ([xs (cdr lst)] [best (car lst)] [current (car lst)]) (if (null? xs) best (let* ([x (car xs)] [current (max x (+ current x))] [best (max best current)]) (loop (cdr xs) best current))))

  - name: longest_palindromic_subsequence
    inputs: ['String']
    input_names: ['s']
    output: "Number"
    racket_symbol: "longest_palindromic_subsequence"
    description: "Longest palindromic subsequence length"
    racket_body: |
      (let* ([n (string-length s)] [dp (build-vector (string-length s) (lambda (_) (make-vector (string-length s) 0)))]) (begin (for ([i (in-range n)]) (vector-set! (vector-ref dp i) i 1)) (for ([len (in-range 2 (+ n 1))]) (for ([i (in-range (- n len -1))]) (let ([j (+ i len -1)]) (if (char=? (string-ref s i) (string-ref s j)) (vector-set! (vector-ref dp i) j (+ (vector-ref (vector-ref dp (+ i 1)) (- j 1)) 2)) (vector-set! (vector-ref dp i) j (max (vector-ref (vector-ref dp (+ i 1)) j) (vector-ref (vector-ref dp i) (- j 1)))))))) (vector-ref (vector-ref dp 0) (- n 1))))

  - name: matrix_chain_multiplication
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "matrix_chain_multiplication"
    description: "Matrix chain multiplication: minimum scalar multiplications"
    racket_body: |
      (let* ([dims (vector 10 30 5 60)] [n 3] [dp (build-vector 3 (lambda (_) (make-vector 3 0)))]) (begin (for ([len (in-range 2 (+ n 1))]) (for ([i (in-range (- n len -1))]) (let ([j (+ i len -1)]) (vector-set! (vector-ref dp i) j +inf.0) (for ([k (in-range i j)]) (let ([cost (+ (vector-ref (vector-ref dp i) k) (vector-ref (vector-ref dp (+ k 1)) j) (* (vector-ref dims i) (vector-ref dims (+ k 1)) (vector-ref dims (+ j 1))))]) (when (< cost (vector-ref (vector-ref dp i) j)) (vector-set! (vector-ref dp i) j cost))))))) (exact-round (vector-ref (vector-ref dp 0) (- n 1)))))

  - name: wagner_fischer
    inputs: ['String', 'String']
    input_names: ['s1', 's2']
    output: "Number"
    racket_symbol: "wagner_fischer"
    description: "Wagner-Fischer: edit distance (same as Levenshtein)"
    racket_body: |
      (let* ([m (string-length s1)] [n (string-length s2)] [dp (build-vector (+ (string-length s1) 1) (lambda (i) (make-vector (+ (string-length s2) 1) 0)))]) (begin (for ([i (in-range (+ m 1))]) (vector-set! (vector-ref dp i) 0 i)) (for ([j (in-range (+ n 1))]) (vector-set! (vector-ref dp 0) j j)) (for* ([i (in-range 1 (+ m 1))] [j (in-range 1 (+ n 1))]) (let ([cost (if (char=? (string-ref s1 (- i 1)) (string-ref s2 (- j 1))) 0 1)]) (vector-set! (vector-ref dp i) j (min (+ (vector-ref (vector-ref dp (- i 1)) j) 1) (+ (vector-ref (vector-ref dp i) (- j 1)) 1) (+ (vector-ref (vector-ref dp (- i 1)) (- j 1)) cost))))) (vector-ref (vector-ref dp m) n)))

  # =========================================================================
  # Encoding
  # =========================================================================

  - name: base64_enc
    inputs: ['String']
    input_names: ['s']
    output: "String"
    racket_symbol: "base64_enc"
    description: "Base64 encode a string"
    racket_body: |
      (let* ([table "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"] [bytes (map char->integer (string->list s))]) (let loop ([bs bytes] [bits 0] [buf 0] [out (list)]) (cond [(and (null? bs) (= bits 0)) (let* ([result (list->string (reverse out))] [pad (modulo (- 4 (modulo (string-length result) 4)) 4)]) (if (= pad 4) result (string-append result (make-string pad #\=))))] [(and (null? bs) (> bits 0)) (loop bs 0 0 (cons (string-ref table (arithmetic-shift buf (- 6 bits))) out))] [(>= (+ bits 8) 6) (let* ([buf (+ (arithmetic-shift buf 8) (car bs))] [bits (+ bits 8)]) (let extract ([bits bits] [buf buf] [out out]) (if (< bits 6) (loop (cdr bs) bits buf out) (extract (- bits 6) (modulo buf (expt 2 (- bits 6))) (cons (string-ref table (quotient buf (expt 2 (- bits 6)))) out)))))] [else (loop (cdr bs) (+ bits 8) (+ (arithmetic-shift buf 8) (car bs)) out)])))

  - name: binary_run_length_encoding
    inputs: ['String']
    input_names: ['s']
    output: "List(Number)"
    racket_symbol: "binary_run_length_encoding"
    description: "Binary run-length encoding: encode binary string as run lengths"
    racket_body: |
      (let* ([chars (string->list s)]) (let loop ([cs chars] [cur #f] [cnt 0] [acc (list)]) (cond [(null? cs) (reverse (if cur (cons cnt acc) acc))] [(equal? (car cs) cur) (loop (cdr cs) cur (+ cnt 1) acc)] [else (loop (cdr cs) (car cs) 1 (if cur (cons cnt acc) acc))])))

  - name: huffman_coding
    inputs: ['String']
    input_names: ['s']
    output: "Number"
    racket_symbol: "huffman_coding"
    description: "Huffman coding: build tree and compute total encoded bits"
    racket_body: |
      (let* ([freq (make-hash)]) (begin (for ([c (in-string s)]) (hash-set! freq c (+ (hash-ref freq c 0) 1))) (let loop ([pq (sort (hash-map freq (lambda (k v) (cons v k))) (lambda (a b) (< (car a) (car b))))]) (if (<= (length pq) 1) (for/sum ([(k v) (in-hash freq)]) (* v (max 1 (- (length (hash-keys freq)) 1)))) (let* ([a (car pq)] [b (cadr pq)] [rest (cddr pq)] [merged (cons (+ (car a) (car b)) (list a b))] [pq (sort (cons merged rest) (lambda (a b) (< (car a) (car b))))]) (loop pq))))))

  - name: vlq_encoding
    inputs: ['Number']
    input_names: ['n']
    output: "List(Number)"
    racket_symbol: "vlq_encoding"
    description: "Variable-length quantity encoding"
    racket_body: |
      (let loop ([x n] [acc (list)]) (let ([byte (bitwise-and x 127)] [rest (arithmetic-shift x -7)]) (if (= rest 0) (reverse (cons byte acc)) (loop rest (cons (bitwise-ior byte 128) acc)))))

  # =========================================================================
  # Geometry
  # =========================================================================

  - name: graham_scan_convex_hull
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "graham_scan_convex_hull"
    description: "Graham scan convex hull: find convex hull of points"
    racket_body: |
      (let* ([pts (list (cons 0 0) (cons 1 1) (cons 2 2) (cons 0 2) (cons 2 0) (cons 1 0))] [cross (lambda (o a b) (- (* (- (car a) (car o)) (- (cdr b) (cdr o))) (* (- (cdr a) (cdr o)) (- (car b) (car o)))))]) (let* ([sorted (sort pts (lambda (a b) (or (< (car a) (car b)) (and (= (car a) (car b)) (< (cdr a) (cdr b))))))] [lower (for/fold ([hull (list)]) ([p (in-list sorted)]) (let trim ([h hull]) (if (and (>= (length h) 2) (<= (cross (second h) (first h) p) 0)) (trim (cdr h)) (cons p h))))] [upper (for/fold ([hull (list)]) ([p (in-list (reverse sorted))]) (let trim ([h hull]) (if (and (>= (length h) 2) (<= (cross (second h) (first h) p) 0)) (trim (cdr h)) (cons p h))))]) (length (remove-duplicates (append (reverse lower) (reverse upper))))))

  - name: line_segment_intersection
    inputs: ['Number']
    input_names: ['n']
    output: "Boolean"
    racket_symbol: "line_segment_intersection"
    description: "Line segment intersection: do segments (0,0)-(2,2) and (0,2)-(2,0) intersect?"
    racket_body: |
      (let* ([cross (lambda (ox oy ax ay bx by) (- (* (- ax ox) (- by oy)) (* (- ay oy) (- bx ox))))]) (let* ([d1 (cross 0 2 2 0 0 0)] [d2 (cross 0 2 2 0 2 2)] [d3 (cross 0 0 2 2 0 2)] [d4 (cross 0 0 2 2 2 0)]) (and (< (* d1 d2) 0) (< (* d3 d4) 0))))

  # =========================================================================
  # Graph
  # =========================================================================

  - name: bfs_traversal
    inputs: ['Number']
    input_names: ['n']
    output: "List(Number)"
    racket_symbol: "bfs_traversal"
    description: "BFS traversal: breadth-first search from start node"
    racket_body: |
      (let* ([adj (vector (list 1 2) (list 3) (list 3 4) (list 5) (list 5) (list))]) (let loop ([queue (list 0)] [visited (set)] [result (list)]) (if (null? queue) (reverse result) (let ([node (car queue)] [rest (cdr queue)]) (if (set-member? visited node) (loop rest visited result) (let ([nbrs (vector-ref adj node)]) (loop (append rest nbrs) (set-add visited node) (cons node result))))))))

  - name: dfs_traversal
    inputs: ['Number']
    input_names: ['n']
    output: "List(Number)"
    racket_symbol: "dfs_traversal"
    description: "DFS traversal: depth-first search from start node"
    racket_body: |
      (let* ([adj (vector (list 1 2) (list 3) (list 3 4) (list 5) (list 5) (list))]) (let loop ([stack (list 0)] [visited (set)] [result (list)]) (if (null? stack) (reverse result) (let ([node (car stack)] [rest (cdr stack)]) (if (set-member? visited node) (loop rest visited result) (let ([nbrs (vector-ref adj node)]) (loop (append nbrs rest) (set-add visited node) (cons node result))))))))

  - name: dijkstra_shortest_path
    inputs: ['Number']
    input_names: ['n']
    output: "List(Number)"
    racket_symbol: "dijkstra_shortest_path"
    description: "Dijkstra's shortest path: find shortest distances from source"
    racket_body: |
      (let* ([adj (vector (list (cons 1 4) (cons 2 1)) (list (cons 3 1)) (list (cons 1 2) (cons 3 5)) (list (cons 4 3)) (list))] [dist (make-vector n +inf.0)]) (begin (vector-set! dist 0 0) (let loop ([pq (list (cons 0 0))]) (if (null? pq) (vector->list dist) (let* ([best (argmin cdr pq)] [u (car best)] [d (cdr best)] [pq (remove best pq)]) (if (> d (vector-ref dist u)) (loop pq) (let ([pq (for/fold ([pq pq]) ([edge (in-list (vector-ref adj u))]) (let* ([v (car edge)] [w (cdr edge)] [nd (+ d w)]) (if (< nd (vector-ref dist v)) (begin (vector-set! dist v nd) (cons (cons v nd) pq)) pq)))]) (loop pq))))))))

  - name: ford_fulkerson_max_flow
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "ford_fulkerson_max_flow"
    description: "Ford-Fulkerson max flow using BFS (Edmonds-Karp)"
    racket_body: |
      (let* ([cap (vector (vector 0 10 10 0 0 0) (vector 0 0 2 4 8 0) (vector 0 0 0 0 9 0) (vector 0 0 0 0 0 10) (vector 0 0 0 6 0 10) (vector 0 0 0 0 0 0))] [bfs (lambda (bfs s t parent) (let ([visited (make-vector n #f)]) (vector-set! visited s #t) (let loop ([queue (list s)]) (cond [(null? queue) (vector-ref visited t)] [else (let ([u (car queue)]) (loop (append (cdr queue) (for/list ([v (in-range n)] #:when (and (not (vector-ref visited v)) (> (vector-ref (vector-ref cap u) v) 0))) (vector-set! visited v #t) (vector-set! parent v u) v))))]))))]) (let flow-loop ([max-flow 0]) (let ([parent (make-vector n -1)]) (if (not (bfs bfs 0 5 parent)) max-flow (let path-flow ([v 5] [pf +inf.0]) (if (= v 0) (begin (let update ([v 5]) (when (not (= v 0)) (let ([u (vector-ref parent v)]) (vector-set! (vector-ref cap u) v (- (vector-ref (vector-ref cap u) v) pf)) (vector-set! (vector-ref cap v) u (+ (vector-ref (vector-ref cap v) u) pf)) (update u)))) (flow-loop (+ max-flow pf))) (path-flow (vector-ref parent v) (min pf (vector-ref (vector-ref cap (vector-ref parent v)) v)))))))))

  - name: kruskal_mst
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "kruskal_mst"
    description: "Kruskal's MST: minimum spanning tree using union-find"
    racket_body: |
      (let* ([edges (sort (list (list 0 1 4) (list 0 2 1) (list 1 2 2) (list 1 3 5) (list 2 3 3)) (lambda (a b) (< (third a) (third b))))] [parent (build-vector 4 values)] [find (lambda (find x) (if (= (vector-ref parent x) x) x (let ([r (find find (vector-ref parent x))]) (vector-set! parent x r) r)))]) (for/fold ([total 0]) ([e (in-list edges)]) (let ([u (find find (first e))] [v (find find (second e))]) (if (= u v) total (begin (vector-set! parent u v) (+ total (third e)))))))

  - name: tarjan_scc
    inputs: ['Number']
    input_names: ['n']
    output: "List(List(Number))"
    racket_symbol: "tarjan_scc"
    description: "Tarjan's SCC: find strongly connected components"
    racket_body: |
      (let* ([adj (vector (list 1) (list 2) (list 0 3) (list 4) (list 3))] [idx (make-vector 5 -1)] [low (make-vector 5 -1)] [on-stack (make-vector 5 #f)] [counter (box 0)] [stack (box (list))] [sccs (box (list))]) (begin (define (strongconnect u) (let ([c (unbox counter)]) (set-box! counter (+ c 1)) (vector-set! idx u c) (vector-set! low u c) (set-box! stack (cons u (unbox stack))) (vector-set! on-stack u #t) (for ([v (in-list (vector-ref adj u))]) (cond [(= (vector-ref idx v) -1) (strongconnect v) (vector-set! low u (min (vector-ref low u) (vector-ref low v)))] [(vector-ref on-stack v) (vector-set! low u (min (vector-ref low u) (vector-ref idx v)))])) (when (= (vector-ref low u) (vector-ref idx u)) (let pop ([scc (list)]) (let ([w (car (unbox stack))]) (set-box! stack (cdr (unbox stack))) (vector-set! on-stack w #f) (if (= w u) (set-box! sccs (cons (cons w scc) (unbox sccs))) (pop (cons w scc)))))))) (for ([i (in-range n)]) (when (= (vector-ref idx i) -1) (strongconnect i))) (unbox sccs)))

  - name: topological_sort
    inputs: ['Number']
    input_names: ['n']
    output: "List(Number)"
    racket_symbol: "topological_sort"
    description: "Topological sort using Kahn's algorithm (BFS-based)"
    racket_body: |
      (let* ([adj (vector (list 1 2) (list 3) (list 3 4) (list 5) (list 5) (list))] [indeg (make-vector 6 0)]) (begin (for* ([u (in-range n)] [v (in-list (vector-ref adj u))]) (vector-set! indeg v (+ (vector-ref indeg v) 1))) (let loop ([queue (for/list ([i (in-range n)] #:when (= (vector-ref indeg i) 0)) i)] [result (list)]) (if (null? queue) (reverse result) (let ([u (car queue)]) (let ([queue (for/fold ([q (cdr queue)]) ([v (in-list (vector-ref adj u))]) (vector-set! indeg v (- (vector-ref indeg v) 1)) (if (= (vector-ref indeg v) 0) (append q (list v)) q))]) (loop queue (cons u result))))))))

  # =========================================================================
  # Number Theory
  # =========================================================================

  - name: chinese_remainder_theorem
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "chinese_remainder_theorem"
    description: "Chinese Remainder Theorem: solve system of congruences"
    racket_body: |
      (let* ([remainders (list 2 3 2)] [moduli (list 3 5 7)] [mod-inv (lambda (a m) (let loop ([old-r a] [r m] [old-s 1] [s 0]) (if (= r 0) (modulo old-s m) (let ([q (quotient old-r r)]) (loop r (- old-r (* q r)) s (- old-s (* q s)))))))]) (let ([N (apply * moduli)]) (modulo (for/sum ([r (in-list remainders)] [m (in-list moduli)]) (let* ([ni (quotient N m)] [xi (mod-inv ni m)]) (* r ni xi))) N)))

  - name: euclidean_gcd
    inputs: ['Number', 'Number']
    input_names: ['a', 'b']
    output: "Number"
    racket_symbol: "euclidean_gcd"
    description: "Euclidean GCD: gcd(a,b) using Euclid's algorithm"
    racket_body: |
      (let loop ([x a] [y b]) (if (= y 0) x (loop y (modulo x y))))

  - name: extended_euclidean_gcd
    inputs: ['Number', 'Number']
    input_names: ['a', 'b']
    output: "List(Number)"
    racket_symbol: "extended_euclidean_gcd"
    description: "Extended Euclidean GCD: find x,y such that ax + by = gcd(a,b)"
    racket_body: |
      (let loop ([old-r a] [r b] [old-s 1] [s 0] [old-t 0] [t 1]) (if (= r 0) (list old-r old-s old-t) (let ([q (quotient old-r r)]) (loop r (- old-r (* q r)) s (- old-s (* q s)) t (- old-t (* q t))))))

  - name: modular_exponentiation
    inputs: ['Number', 'Number', 'Number']
    input_names: ['base', 'exp', 'm']
    output: "Number"
    racket_symbol: "modular_exponentiation"
    description: "Modular exponentiation: (base^exp) mod m using fast exponentiation"
    racket_body: |
      (let loop ([b base] [e exp] [result 1]) (if (= e 0) result (let ([result (if (odd? e) (modulo (* result b) m) result)]) (loop (modulo (* b b) m) (quotient e 2) result))))

  - name: primality_trial_division
    inputs: ['Number']
    input_names: ['n']
    output: "Boolean"
    racket_symbol: "primality_trial_division"
    description: "Primality test by trial division"
    racket_body: |
      (let loop ([i 2]) (cond [(> (* i i) n) #t] [(= (modulo n i) 0) #f] [else (loop (+ i 1))]))

  - name: prime_factorization
    inputs: ['Number']
    input_names: ['n']
    output: "List(Number)"
    racket_symbol: "prime_factorization"
    description: "Prime factorization: list prime factors of n"
    racket_body: |
      (let loop ([x n] [d 2] [acc (list)]) (cond [(> (* d d) x) (if (> x 1) (append acc (list x)) acc)] [(= (modulo x d) 0) (loop (quotient x d) d (append acc (list d)))] [else (loop x (+ d 1) acc)]))

  # =========================================================================
  # Searching
  # =========================================================================

  - name: binary_search
    inputs: ['List(Number)', 'Number']
    input_names: ['lst', 'target']
    output: "Number"
    racket_symbol: "binary_search"
    description: "Binary search: find index of target in sorted list, -1 if not found"
    racket_body: |
      (let loop ([lo 0] [hi (-(length lst) 1)]) (if (> lo hi) -1 (let ([mid (quotient (+ lo hi) 2)]) (let ([v (list-ref lst mid)]) (cond [(= v target) mid] [(< v target) (loop (+ mid 1) hi)] [else (loop lo (- mid 1))])))))

  - name: boyer_moore_majority_vote
    inputs: ['List(Number)']
    input_names: ['lst']
    output: "Number"
    racket_symbol: "boyer_moore_majority_vote"
    description: "Boyer-Moore majority vote: find element appearing > n/2 times"
    racket_body: |
      (let loop ([xs lst] [candidate 0] [count 0]) (if (null? xs) candidate (let ([x (car xs)]) (if (= count 0) (loop (cdr xs) x 1) (if (= x candidate) (loop (cdr xs) candidate (+ count 1)) (loop (cdr xs) candidate (- count 1)))))))

  - name: exponential_search
    inputs: ['List(Number)', 'Number']
    input_names: ['lst', 'target']
    output: "Number"
    racket_symbol: "exponential_search"
    description: "Exponential search: find range then binary search"
    racket_body: |
      (let* ([n (length lst)] [bsearch (lambda (bsearch lo hi) (if (> lo hi) -1 (let ([mid (quotient (+ lo hi) 2)]) (cond [(= (list-ref lst mid) target) mid] [(< (list-ref lst mid) target) (bsearch bsearch (+ mid 1) hi)] [else (bsearch bsearch lo (- mid 1))]))))]) (if (= (list-ref lst 0) target) 0 (let bound ([i 1]) (if (and (< i n) (<= (list-ref lst i) target)) (bound (* i 2)) (bsearch bsearch (quotient i 2) (min (- i 1) (- n 1)))))))

  - name: fibonacci_search
    inputs: ['List(Number)', 'Number']
    input_names: ['lst', 'target']
    output: "Number"
    racket_symbol: "fibonacci_search"
    description: "Fibonacci search: search sorted list using Fibonacci numbers"
    racket_body: |
      (let* ([n (length lst)]) (let fib-init ([f2 0] [f1 1]) (let ([f (+ f2 f1)]) (if (>= f n) (let loop ([f2 f2] [f1 f1] [f f] [offset -1]) (cond [(< f 1) -1] [else (let ([i (min (+ offset f2) (- n 1))]) (cond [(< (list-ref lst i) target) (loop (- f1 f2) f2 f1 i)] [(> (list-ref lst i) target) (loop (- f2 (- f1 f2)) (- f1 f2) f2 offset)] [else i]))])) (fib-init f1 f)))))

  - name: interpolation_search
    inputs: ['List(Number)', 'Number']
    input_names: ['lst', 'target']
    output: "Number"
    racket_symbol: "interpolation_search"
    description: "Interpolation search: search sorted uniformly distributed list"
    racket_body: |
      (let loop ([lo 0] [hi (-(length lst) 1)]) (if (or (> lo hi) (= (list-ref lst lo) (list-ref lst hi))) (if (and (<= lo hi) (= (list-ref lst lo) target)) lo -1) (let* ([lo-val (list-ref lst lo)] [hi-val (list-ref lst hi)] [pos (+ lo (quotient (* (- target lo-val) (- hi lo)) (- hi-val lo-val)))]) (cond [(or (< pos lo) (> pos hi)) -1] [(= (list-ref lst pos) target) pos] [(< (list-ref lst pos) target) (loop (+ pos 1) hi)] [else (loop lo (- pos 1))]))))

  - name: jump_search
    inputs: ['List(Number)', 'Number']
    input_names: ['lst', 'target']
    output: "Number"
    racket_symbol: "jump_search"
    description: "Jump search: search sorted list with jump size sqrt(n)"
    racket_body: |
      (let* ([n (length lst)] [step (exact-floor (sqrt (length lst)))]) (let jump ([prev 0] [curr (min step n)]) (cond [(>= prev n) -1] [(< (list-ref lst (- curr 1)) target) (jump curr (min (+ curr step) n))] [else (let scan ([i prev]) (cond [(= i curr) -1] [(= (list-ref lst i) target) i] [else (scan (+ i 1))]))])))

  - name: linear_search
    inputs: ['List(Number)', 'Number']
    input_names: ['lst', 'target']
    output: "Number"
    racket_symbol: "linear_search"
    description: "Linear search: find index of target in list, -1 if not found"
    racket_body: |
      (let loop ([i 0]) (cond [(= i (length lst)) -1] [(= (list-ref lst i) target) i] [else (loop (+ i 1))]))

  - name: median_two_sorted_arrays
    inputs: ['List(Number)', 'List(Number)']
    input_names: ['a', 'b']
    output: "Number"
    racket_symbol: "median_two_sorted_arrays"
    description: "Median of two sorted arrays"
    racket_body: |
      (let* ([merged (let merge ([a a] [b b] [acc (list)]) (cond [(null? a) (append (reverse acc) b)] [(null? b) (append (reverse acc) a)] [(<= (car a) (car b)) (merge (cdr a) b (cons (car a) acc))] [else (merge a (cdr b) (cons (car b) acc))]))] [n (+ (length a) (length b))]) (if (odd? n) (list-ref merged (quotient n 2)) (/ (+ (list-ref merged (- (quotient n 2) 1)) (list-ref merged (quotient n 2))) 2)))

  - name: quickselect
    inputs: ['List(Number)', 'Number']
    input_names: ['lst', 'k']
    output: "Number"
    racket_symbol: "quickselect"
    description: "Quickselect: find k-th smallest element (0-indexed)"
    racket_body: |
      (let* ([qs (lambda (qs xs k) (let* ([pivot (car xs)] [rest (cdr xs)] [lo (filter (lambda (x) (< x pivot)) rest)] [hi (filter (lambda (x) (>= x pivot)) rest)] [lo-len (length lo)]) (cond [(= k lo-len) pivot] [(< k lo-len) (qs qs lo k)] [else (qs qs hi (- k lo-len 1))])))]) (qs qs lst k))

  - name: sentinel_linear_search
    inputs: ['List(Number)', 'Number']
    input_names: ['lst', 'target']
    output: "Number"
    racket_symbol: "sentinel_linear_search"
    description: "Sentinel linear search: place target at end to avoid bounds check"
    racket_body: |
      (let* ([v (list->vector lst)] [n (vector-length (list->vector lst))] [last (vector-ref (list->vector lst) (- (vector-length (list->vector lst)) 1))]) (begin (vector-set! v (- n 1) target) (let loop ([i 0]) (if (= (vector-ref v i) target) (if (or (< i (- n 1)) (= last target)) i -1) (loop (+ i 1))))))

  - name: ternary_search
    inputs: ['List(Number)', 'Number']
    input_names: ['lst', 'target']
    output: "Number"
    racket_symbol: "ternary_search"
    description: "Ternary search: find target in sorted list using three-way split"
    racket_body: |
      (let loop ([lo 0] [hi (-(length lst) 1)]) (if (> lo hi) -1 (let* ([third (quotient (- hi lo) 3)] [m1 (+ lo third)] [m2 (- hi third)]) (cond [(= (list-ref lst m1) target) m1] [(= (list-ref lst m2) target) m2] [(< target (list-ref lst m1)) (loop lo (- m1 1))] [(> target (list-ref lst m2)) (loop (+ m2 1) hi)] [else (loop (+ m1 1) (- m2 1))]))))

  - name: two_sum_sorted
    inputs: ['List(Number)', 'Number']
    input_names: ['lst', 'target']
    output: "List(Number)"
    racket_symbol: "two_sum_sorted"
    description: "Two sum on sorted array: find indices of two elements that sum to target"
    racket_body: |
      (let loop ([lo 0] [hi (-(length lst) 1)]) (let ([s (+ (list-ref lst lo) (list-ref lst hi))]) (cond [(= s target) (list lo hi)] [(< s target) (loop (+ lo 1) hi)] [else (loop lo (- hi 1))])))

  # =========================================================================
  # Sorting
  # =========================================================================

  - name: bubble_sort
    inputs: ['List(Number)']
    input_names: ['lst']
    output: "List(Number)"
    racket_symbol: "bubble_sort"
    description: "Bubble sort"
    racket_body: |
      (let outer ([xs lst] [n (length lst)]) (if (<= n 1) xs (let ([result (for/fold ([acc xs]) ([i (in-range (- n 1))]) (let ([a (list-ref acc i)] [b (list-ref acc (+ i 1))]) (if (> a b) (append (take acc i) (list b a) (drop acc (+ i 2))) acc)))]) (outer result (- n 1)))))

  - name: bucket_sort
    inputs: ['List(Number)']
    input_names: ['lst']
    output: "List(Number)"
    racket_symbol: "bucket_sort"
    description: "Bucket sort for numbers in [0, 1) range (scaled to integers)"
    racket_body: |
      (let* ([n (length lst)] [mx (+ (apply max lst) 1)] [buckets (build-vector (length lst) (lambda (_) (list)))]) (begin (for-each (lambda (x) (let ([idx (min (- n 1) (quotient (* x n) mx))]) (vector-set! buckets idx (cons x (vector-ref buckets idx))))) lst) (for*/list ([i (in-range n)] [x (in-list (sort (vector-ref buckets i) <))]) x)))

  - name: counting_sort
    inputs: ['List(Number)']
    input_names: ['lst']
    output: "List(Number)"
    racket_symbol: "counting_sort"
    description: "Counting sort: sort non-negative integers by counting occurrences"
    racket_body: |
      (let* ([mx (apply max lst)] [counts (make-vector (+ mx 1) 0)]) (begin (for-each (lambda (x) (vector-set! counts x (+ (vector-ref counts x) 1))) lst) (for*/list ([i (in-range (+ mx 1))] [_ (in-range (vector-ref counts i))]) i)))

  - name: heap_sort
    inputs: ['List(Number)']
    input_names: ['lst']
    output: "List(Number)"
    racket_symbol: "heap_sort"
    description: "Heap sort using Racket's built-in sort (heap-based)"
    racket_body: |
      (let* ([sift-down (lambda (sift-down vec n i) (let loop ([i i]) (let* ([largest i] [l (+ (* 2 i) 1)] [r (+ (* 2 i) 2)] [largest (if (and (< l n) (> (vector-ref vec l) (vector-ref vec largest))) l largest)] [largest (if (and (< r n) (> (vector-ref vec r) (vector-ref vec largest))) r largest)]) (when (not (= largest i)) (let ([tmp (vector-ref vec i)]) (vector-set! vec i (vector-ref vec largest)) (vector-set! vec largest tmp) (loop largest))))))]) (let ([v (list->vector lst)] [n (length lst)]) (for ([i (in-range (- (quotient n 2) 1) -1 -1)]) (sift-down sift-down v n i)) (for ([i (in-range (- n 1) 0 -1)]) (let ([tmp (vector-ref v 0)]) (vector-set! v 0 (vector-ref v i)) (vector-set! v i tmp) (sift-down sift-down v i 0))) (vector->list v)))

  - name: merge_sort
    inputs: ['List(Number)']
    input_names: ['lst']
    output: "List(Number)"
    racket_symbol: "merge_sort"
    description: "Merge sort"
    racket_body: |
      (let* ([merge (lambda (a b) (let loop ([a a] [b b] [acc (list)]) (cond [(null? a) (append (reverse acc) b)] [(null? b) (append (reverse acc) a)] [(<= (car a) (car b)) (loop (cdr a) b (cons (car a) acc))] [else (loop a (cdr b) (cons (car b) acc))])))] [msort (lambda (msort xs) (if (<= (length xs) 1) xs (let-values ([(l r) (split-at xs (quotient (length xs) 2))]) (merge (msort msort l) (msort msort r)))))]) (msort msort lst))

  - name: quicksort
    inputs: ['List(Number)']
    input_names: ['lst']
    output: "List(Number)"
    racket_symbol: "quicksort"
    description: "Quicksort"
    racket_body: |
      (let* ([qsort (lambda (qsort xs) (if (<= (length xs) 1) xs (let* ([pivot (car xs)] [rest (cdr xs)] [lo (filter (lambda (x) (< x pivot)) rest)] [hi (filter (lambda (x) (>= x pivot)) rest)]) (append (qsort qsort lo) (list pivot) (qsort qsort hi)))))]) (qsort qsort lst))

  - name: radix_sort
    inputs: ['List(Number)']
    input_names: ['lst']
    output: "List(Number)"
    racket_symbol: "radix_sort"
    description: "Radix sort (LSD, base 10)"
    racket_body: |
      (let* ([mx (apply max lst)]) (let loop ([xs lst] [exp 1]) (if (> exp mx) xs (let ([buckets (make-vector 10 (list))]) (for-each (lambda (x) (let ([d (modulo (quotient x exp) 10)]) (vector-set! buckets d (append (vector-ref buckets d) (list x))))) xs) (loop (for*/list ([i (in-range 10)] [x (in-list (vector-ref buckets i))]) x) (* exp 10))))))

  - name: selection_sort
    inputs: ['List(Number)']
    input_names: ['lst']
    output: "List(Number)"
    racket_symbol: "selection_sort"
    description: "Selection sort"
    racket_body: |
      (let loop ([xs lst] [acc (list)]) (if (null? xs) (reverse acc) (let* ([mn (apply min xs)] [rest (let rem ([l xs] [found #f]) (cond [(null? l) (list)] [(and (= (car l) mn) (not found)) (rem (cdr l) #t)] [else (cons (car l) (rem (cdr l) found))]))]) (loop rest (cons mn acc)))))

  - name: shellsort
    inputs: ['List(Number)']
    input_names: ['lst']
    output: "List(Number)"
    racket_symbol: "shellsort"
    description: "Shell sort with gap sequence n/2, n/4, ..., 1"
    racket_body: |
      (let* ([v (list->vector lst)] [n (length lst)]) (let gap-loop ([gap (quotient n 2)]) (if (= gap 0) (vector->list v) (begin (for ([i (in-range gap n)]) (let ([tmp (vector-ref v i)]) (let j-loop ([j i]) (if (and (>= j gap) (> (vector-ref v (- j gap)) tmp)) (begin (vector-set! v j (vector-ref v (- j gap))) (j-loop (- j gap))) (vector-set! v j tmp))))) (gap-loop (quotient gap 2))))))

  # =========================================================================
  # String
  # =========================================================================

  - name: caesar_cipher
    inputs: ['String', 'Number']
    input_names: ['s', 'k']
    output: "String"
    racket_symbol: "caesar_cipher"
    description: "Caesar cipher: shift each letter by k positions"
    racket_body: |
      (let* ([chars (string->list s)]) (list->string (map (lambda (c) (if (char-alphabetic? c) (let* ([base (if (char-upper-case? c) 65 97)] [shifted (modulo (+ (- (char->integer c) base) k) 26)]) (integer->char (+ base shifted))) c)) chars)))

  - name: damerau_levenshtein
    inputs: ['String', 'String']
    input_names: ['s1', 's2']
    output: "Number"
    racket_symbol: "damerau_levenshtein"
    description: "Damerau-Levenshtein distance (with transpositions)"
    racket_body: |
      (let* ([m (string-length s1)] [n (string-length s2)] [dp (build-vector (+ (string-length s1) 1) (lambda (i) (make-vector (+ (string-length s2) 1) 0)))]) (begin (for ([i (in-range (+ m 1))]) (vector-set! (vector-ref dp i) 0 i)) (for ([j (in-range (+ n 1))]) (vector-set! (vector-ref dp 0) j j)) (for* ([i (in-range 1 (+ m 1))] [j (in-range 1 (+ n 1))]) (let ([cost (if (char=? (string-ref s1 (- i 1)) (string-ref s2 (- j 1))) 0 1)]) (vector-set! (vector-ref dp i) j (min (+ (vector-ref (vector-ref dp (- i 1)) j) 1) (+ (vector-ref (vector-ref dp i) (- j 1)) 1) (+ (vector-ref (vector-ref dp (- i 1)) (- j 1)) cost))) (when (and (> i 1) (> j 1) (char=? (string-ref s1 (- i 1)) (string-ref s2 (- j 2))) (char=? (string-ref s1 (- i 2)) (string-ref s2 (- j 1)))) (vector-set! (vector-ref dp i) j (min (vector-ref (vector-ref dp i) j) (+ (vector-ref (vector-ref dp (- i 2)) (- j 2)) cost)))))) (vector-ref (vector-ref dp m) n)))

  - name: knuth_morris_pratt
    inputs: ['String', 'String']
    input_names: ['text', 'pattern']
    output: "Number"
    racket_symbol: "knuth_morris_pratt"
    description: "KMP string search: find first occurrence of pattern in text"
    racket_body: |
      (let* ([m (string-length pattern)] [n (string-length text)] [lps (make-vector (string-length pattern) 0)]) (begin (let build ([i 1] [len 0]) (when (< i m) (cond [(char=? (string-ref pattern i) (string-ref pattern len)) (vector-set! lps i (+ len 1)) (build (+ i 1) (+ len 1))] [(> len 0) (build i (vector-ref lps (- len 1)))] [else (vector-set! lps i 0) (build (+ i 1) 0)]))) (let search ([i 0] [j 0]) (cond [(= j m) (- i m)] [(= i n) -1] [(char=? (string-ref text i) (string-ref pattern j)) (search (+ i 1) (+ j 1))] [(> j 0) (search i (vector-ref lps (- j 1)))] [else (search (+ i 1) 0)]))))

  - name: levenshtein_edit_distance
    inputs: ['String', 'String']
    input_names: ['s1', 's2']
    output: "Number"
    racket_symbol: "levenshtein_edit_distance"
    description: "Levenshtein edit distance using DP"
    racket_body: |
      (let* ([m (string-length s1)] [n (string-length s2)] [dp (build-vector (+ (string-length s1) 1) (lambda (i) (make-vector (+ (string-length s2) 1) 0)))]) (begin (for ([i (in-range (+ m 1))]) (vector-set! (vector-ref dp i) 0 i)) (for ([j (in-range (+ n 1))]) (vector-set! (vector-ref dp 0) j j)) (for* ([i (in-range 1 (+ m 1))] [j (in-range 1 (+ n 1))]) (let ([cost (if (char=? (string-ref s1 (- i 1)) (string-ref s2 (- j 1))) 0 1)]) (vector-set! (vector-ref dp i) j (min (+ (vector-ref (vector-ref dp (- i 1)) j) 1) (+ (vector-ref (vector-ref dp i) (- j 1)) 1) (+ (vector-ref (vector-ref dp (- i 1)) (- j 1)) cost))))) (vector-ref (vector-ref dp m) n)))

  - name: longest_common_subsequence
    inputs: ['String', 'String']
    input_names: ['s1', 's2']
    output: "Number"
    racket_symbol: "longest_common_subsequence"
    description: "Longest common subsequence length"
    racket_body: |
      (let* ([m (string-length s1)] [n (string-length s2)] [dp (build-vector (+ (string-length s1) 1) (lambda (_) (make-vector (+ (string-length s2) 1) 0)))]) (begin (for* ([i (in-range 1 (+ m 1))] [j (in-range 1 (+ n 1))]) (vector-set! (vector-ref dp i) j (if (char=? (string-ref s1 (- i 1)) (string-ref s2 (- j 1))) (+ (vector-ref (vector-ref dp (- i 1)) (- j 1)) 1) (max (vector-ref (vector-ref dp (- i 1)) j) (vector-ref (vector-ref dp i) (- j 1)))))) (vector-ref (vector-ref dp m) n)))

  - name: longest_common_substring
    inputs: ['String', 'String']
    input_names: ['s1', 's2']
    output: "Number"
    racket_symbol: "longest_common_substring"
    description: "Longest common substring length"
    racket_body: |
      (let* ([m (string-length s1)] [n (string-length s2)] [dp (build-vector (+ (string-length s1) 1) (lambda (_) (make-vector (+ (string-length s2) 1) 0)))] [best (box 0)]) (begin (for* ([i (in-range 1 (+ m 1))] [j (in-range 1 (+ n 1))]) (when (char=? (string-ref s1 (- i 1)) (string-ref s2 (- j 1))) (let ([v (+ (vector-ref (vector-ref dp (- i 1)) (- j 1)) 1)]) (vector-set! (vector-ref dp i) j v) (when (> v (unbox best)) (set-box! best v))))) (unbox best)))

  - name: manacher_longest_palindrome
    inputs: ['String']
    input_names: ['s']
    output: "Number"
    racket_symbol: "manacher_longest_palindrome"
    description: "Manacher's algorithm: longest palindromic substring length"
    racket_body: |
      (let* ([n (string-length s)] [best (box 1)]) (begin (for ([center (in-range n)]) (let expand-odd ([l center] [r center]) (when (and (>= l 0) (< r n) (char=? (string-ref s l) (string-ref s r))) (set-box! best (max (unbox best) (+ (- r l) 1))) (expand-odd (- l 1) (+ r 1)))) (let expand-even ([l center] [r (+ center 1)]) (when (and (>= l 0) (< r n) (char=? (string-ref s l) (string-ref s r))) (set-box! best (max (unbox best) (+ (- r l) 1))) (expand-even (- l 1) (+ r 1))))) (unbox best)))

  - name: rabin_karp
    inputs: ['String', 'String']
    input_names: ['text', 'pattern']
    output: "Number"
    racket_symbol: "rabin_karp"
    description: "Rabin-Karp string search using rolling hash"
    racket_body: |
      (let* ([m (string-length pattern)] [n (string-length text)] [base 256] [mod 101]) (let* ([ph (for/fold ([h 0]) ([c (in-string pattern)]) (modulo (+ (* h base) (char->integer c)) mod))] [th (for/fold ([h 0]) ([c (in-string (substring text 0 m))]) (modulo (+ (* h base) (char->integer c)) mod))] [pow (for/fold ([p 1]) ([_ (in-range (- m 1))]) (modulo (* p base) mod))]) (let search ([i 0] [th th]) (cond [(= i (- n m -1)) -1] [(and (= ph th) (string=? (substring text i (+ i m)) pattern)) i] [else (search (+ i 1) (modulo (+ (* (- th (* (char->integer (string-ref text i)) pow)) base) (char->integer (string-ref text (+ i m)))) mod))]))))

  - name: rot13_cipher
    inputs: ['String']
    input_names: ['s']
    output: "String"
    racket_symbol: "rot13_cipher"
    description: "ROT13: Caesar cipher with shift 13"
    racket_body: |
      (let* ([chars (string->list s)]) (list->string (map (lambda (c) (if (char-alphabetic? c) (let* ([base (if (char-upper-case? c) 65 97)] [shifted (modulo (+ (- (char->integer c) base) 13) 26)]) (integer->char (+ base shifted))) c)) chars)))

  - name: run_length_encoding
    inputs: ['String']
    input_names: ['s']
    output: "String"
    racket_symbol: "run_length_encoding"
    description: "Run-length encoding: compress consecutive chars"
    racket_body: |
      (let* ([chars (string->list s)]) (let loop ([cs chars] [result ""] [cur #f] [cnt 0]) (cond [(null? cs) (if cur (string-append result (number->string cnt) (string cur)) result)] [(equal? (car cs) cur) (loop (cdr cs) result cur (+ cnt 1))] [else (let ([result (if cur (string-append result (number->string cnt) (string cur)) result)]) (loop (cdr cs) result (car cs) 1))])))

  # =========================================================================
  # Arithmetic (new)
  # =========================================================================

  - name: ackermann
    inputs: ['Number', 'Number']
    input_names: ['m', 'n']
    output: "Number"
    racket_symbol: "ackermann"
    description: "Ackermann function: A(m,n) — fast-growing recursive function"
    racket_body: |
      (let* ([ack (lambda (ack m n) (cond [(= m 0) (+ n 1)] [(= n 0) (ack ack (- m 1) 1)] [else (ack ack (- m 1) (ack ack m (- n 1)))]))]) (ack ack m n))

  - name: catalan_number_compute
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "catalan_number_compute"
    description: "Catalan number: C(n) = (2n choose n) / (n+1)"
    racket_body: |
      (let* ([binom (lambda (binom n k) (if (or (= k 0) (= k n)) 1 (+ (binom binom (- n 1) (- k 1)) (binom binom (- n 1) k))))]) (quotient (binom binom (* 2 n) n) (+ n 1)))

  - name: perfect_number_check
    inputs: ['Number']
    input_names: ['n']
    output: "Boolean"
    racket_symbol: "perfect_number_check"
    description: "Perfect number check: sum of proper divisors equals n"
    racket_body: |
      (= n (for/sum ([i (in-range 1 n)]) (if (= (modulo n i) 0) i 0)))

  - name: happy_number_check
    inputs: ['Number']
    input_names: ['n']
    output: "Boolean"
    racket_symbol: "happy_number_check"
    description: "Happy number check: repeatedly sum squares of digits until 1 or cycle"
    racket_body: |
      (let* ([digit-sq-sum (lambda (x) (for/sum ([c (in-string (number->string x))]) (expt (- (char->integer c) 48) 2)))]) (let loop ([slow n] [fast (digit-sq-sum n)]) (cond [(= fast 1) #t] [(= slow fast) #f] [else (loop (digit-sq-sum slow) (digit-sq-sum (digit-sq-sum fast)))])))

  - name: integer_to_roman
    inputs: ['Number']
    input_names: ['n']
    output: "String"
    racket_symbol: "integer_to_roman"
    description: "Integer to Roman numeral conversion"
    racket_body: |
      (let ([vals '(1000 900 500 400 100 90 50 40 10 9 5 4 1)] [syms '("M" "CM" "D" "CD" "C" "XC" "L" "XL" "X" "IX" "V" "IV" "I")]) (let loop ([n n] [vs vals] [ss syms] [acc ""]) (cond [(null? vs) acc] [(>= n (car vs)) (loop (- n (car vs)) vs ss (string-append acc (car ss)))] [else (loop n (cdr vs) (cdr ss) acc)])))

  - name: roman_to_integer
    inputs: ['String']
    input_names: ['s']
    output: "Number"
    racket_symbol: "roman_to_integer"
    description: "Roman numeral to integer conversion"
    racket_body: |
      (let ([val (lambda (c) (case c [(#\M) 1000] [(#\D) 500] [(#\C) 100] [(#\L) 50] [(#\X) 10] [(#\V) 5] [(#\I) 1] [else 0]))]) (let* ([chars (string->list s)] [n (length chars)]) (let loop ([i 0] [total 0]) (if (>= i n) total (let ([cur (val (list-ref chars i))] [nxt (if (< (+ i 1) n) (val (list-ref chars (+ i 1))) 0)]) (if (< cur nxt) (loop (+ i 2) (+ total (- nxt cur))) (loop (+ i 1) (+ total cur))))))))

  # =========================================================================
  # Bitwise (new)
  # =========================================================================

  - name: hamming_weight
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "hamming_weight"
    description: "Hamming weight: count set bits using Brian Kernighan's method"
    racket_body: |
      (let loop ([x n] [c 0]) (if (= x 0) c (loop (bitwise-and x (- x 1)) (+ c 1))))

  - name: next_power_of_two
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "next_power_of_two"
    description: "Next power of two: smallest 2^k >= n"
    racket_body: |
      (let loop ([p 1]) (if (>= p n) p (loop (* p 2))))

  - name: count_trailing_zeros
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "count_trailing_zeros"
    description: "Count trailing zeros in binary representation"
    racket_body: |
      (if (= n 0) -1 (let loop ([x n] [c 0]) (if (= (bitwise-and x 1) 1) c (loop (arithmetic-shift x -1) (+ c 1)))))

  - name: bit_parity
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "bit_parity"
    description: "Bit parity: 1 if odd number of set bits, 0 if even"
    racket_body: |
      (let loop ([x n] [p 0]) (if (= x 0) p (loop (arithmetic-shift x -1) (bitwise-xor p (bitwise-and x 1)))))

  # =========================================================================
  # Combinatorics (new)
  # =========================================================================

  - name: bell_number
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "bell_number"
    description: "Bell number: B(n) counts partitions of a set of n elements"
    racket_body: |
      (if (= n 0) 1 (let* ([prev (make-vector n 0)] [cur (make-vector n 0)]) (vector-set! prev 0 1) (for ([i (in-range 1 n)]) (vector-set! cur 0 (vector-ref prev (- i 1))) (for ([j (in-range 1 (+ i 1))]) (vector-set! cur j (+ (vector-ref cur (- j 1)) (vector-ref prev (- j 1))))) (for ([j (in-range (+ i 1))]) (vector-set! prev j (vector-ref cur j)))) (vector-ref prev (- n 1))))

  - name: stirling_second
    inputs: ['Number', 'Number']
    input_names: ['n', 'k']
    output: "Number"
    racket_symbol: "stirling_second"
    description: "Stirling number of the second kind: S(n,k) partitions of n into k non-empty subsets"
    racket_body: |
      (let* ([f (lambda (f n k) (cond [(= n 0) (if (= k 0) 1 0)] [(= k 0) 0] [(= k 1) 1] [(= k n) 1] [else (+ (* k (f f (- n 1) k)) (f f (- n 1) (- k 1)))]))]) (f f n k))

  - name: generate_permutations
    inputs: ['Number']
    input_names: ['n']
    output: "List(List(Number))"
    racket_symbol: "generate_permutations"
    description: "Generate all permutations of (1..n)"
    racket_body: |
      (let* ([perm (lambda (perm lst) (if (null? lst) (list (list)) (apply append (map (lambda (x) (map (lambda (p) (cons x p)) (perm perm (remove x lst)))) lst))))]) (perm perm (build-list n (lambda (i) (+ i 1)))))

  - name: generate_combinations
    inputs: ['Number', 'Number']
    input_names: ['n', 'k']
    output: "List(List(Number))"
    racket_symbol: "generate_combinations"
    description: "Generate all k-combinations of (1..n)"
    racket_body: |
      (let* ([comb (lambda (comb start k) (if (= k 0) (list (list)) (apply append (for/list ([i (in-range start (+ n 1))]) (map (lambda (c) (cons i c)) (comb comb (+ i 1) (- k 1)))))))]) (comb comb 1 k))

  # =========================================================================
  # Data Structures (new)
  # =========================================================================

  - name: stack_operations
    inputs: ['List(Number)']
    input_names: ['ops']
    output: "List(Number)"
    racket_symbol: "stack_operations"
    description: "Stack simulation: push positive, pop on 0, return final stack"
    racket_body: |
      (let loop ([xs ops] [stk (list)]) (if (null? xs) (reverse stk) (let ([x (car xs)]) (if (= x 0) (loop (cdr xs) (if (null? stk) stk (cdr stk))) (loop (cdr xs) (cons x stk))))))

  - name: queue_operations
    inputs: ['List(Number)']
    input_names: ['ops']
    output: "List(Number)"
    racket_symbol: "queue_operations"
    description: "Queue simulation: enqueue positive, dequeue on 0, return dequeued values"
    racket_body: |
      (let loop ([xs ops] [q (list)] [out (list)]) (if (null? xs) (reverse out) (let ([x (car xs)]) (if (= x 0) (if (null? q) (loop (cdr xs) q out) (loop (cdr xs) (cdr q) (cons (car q) out))) (loop (cdr xs) (append q (list x)) out)))))

  - name: binary_search_tree_insert
    inputs: ['List(Number)']
    input_names: ['vals']
    output: "List(Number)"
    racket_symbol: "binary_search_tree_insert"
    description: "BST insert then inorder traversal (produces sorted output)"
    racket_body: |
      (let* ([insert (lambda (insert tree val) (if (null? tree) (list val (list) (list)) (let ([root (car tree)] [left (cadr tree)] [right (caddr tree)]) (if (< val root) (list root (insert insert left val) right) (list root left (insert insert right val))))))] [inorder (lambda (inorder tree) (if (null? tree) (list) (append (inorder inorder (cadr tree)) (list (car tree)) (inorder inorder (caddr tree)))))]) (let ([tree (foldl (lambda (v t) (insert insert t v)) (list) vals)]) (inorder inorder tree)))

  - name: max_stack
    inputs: ['List(Number)']
    input_names: ['ops']
    output: "List(Number)"
    racket_symbol: "max_stack"
    description: "Max stack: push positive, pop on 0, query max on -1; return max queries"
    racket_body: |
      (let loop ([xs ops] [stk (list)] [out (list)]) (if (null? xs) (reverse out) (let ([x (car xs)]) (cond [(= x -1) (loop (cdr xs) stk (cons (if (null? stk) -1 (apply max stk)) out))] [(= x 0) (loop (cdr xs) (if (null? stk) stk (cdr stk)) out)] [else (loop (cdr xs) (cons x stk) out)]))))

  # =========================================================================
  # Dynamic Programming (new)
  # =========================================================================

  - name: house_robber
    inputs: ['List(Number)']
    input_names: ['nums']
    output: "Number"
    racket_symbol: "house_robber"
    description: "House robber: max sum of non-adjacent elements"
    racket_body: |
      (let loop ([xs nums] [prev2 0] [prev1 0]) (if (null? xs) prev1 (loop (cdr xs) prev1 (max prev1 (+ prev2 (car xs))))))

  - name: min_cost_climbing_stairs
    inputs: ['List(Number)']
    input_names: ['cost']
    output: "Number"
    racket_symbol: "min_cost_climbing_stairs"
    description: "Min cost climbing stairs: pay cost[i] to step from i, reach top"
    racket_body: |
      (let* ([n (length cost)] [v (list->vector cost)]) (let loop ([i 2] [a (vector-ref v 0)] [b (vector-ref v 1)]) (if (= i n) (min a b) (loop (+ i 1) b (+ (vector-ref v i) (min a b))))))

  - name: longest_common_subseq_length
    inputs: ['String', 'String']
    input_names: ['a', 'b']
    output: "Number"
    racket_symbol: "longest_common_subseq_length"
    description: "Longest common subsequence length between two strings"
    racket_body: |
      (let* ([m (string-length a)] [n (string-length b)] [dp (for/vector ([i (in-range (+ m 1))]) (make-vector (+ n 1) 0))]) (for ([i (in-range 1 (+ m 1))]) (for ([j (in-range 1 (+ n 1))]) (vector-set! (vector-ref dp i) j (if (char=? (string-ref a (- i 1)) (string-ref b (- j 1))) (+ 1 (vector-ref (vector-ref dp (- i 1)) (- j 1))) (max (vector-ref (vector-ref dp (- i 1)) j) (vector-ref (vector-ref dp i) (- j 1))))))) (vector-ref (vector-ref dp m) n))

  - name: unique_paths_grid
    inputs: ['Number', 'Number']
    input_names: ['m', 'n']
    output: "Number"
    racket_symbol: "unique_paths_grid"
    description: "Unique paths in m×n grid: top-left to bottom-right, only right/down"
    racket_body: |
      (let* ([dp (make-vector n 1)]) (for ([i (in-range 1 m)]) (for ([j (in-range 1 n)]) (vector-set! dp j (+ (vector-ref dp j) (vector-ref dp (- j 1)))))) (vector-ref dp (- n 1)))

  - name: max_subarray_product
    inputs: ['List(Number)']
    input_names: ['nums']
    output: "Number"
    racket_symbol: "max_subarray_product"
    description: "Maximum subarray product: contiguous subarray with largest product"
    racket_body: |
      (let loop ([xs (cdr nums)] [mx (car nums)] [mn (car nums)] [best (car nums)]) (if (null? xs) best (let* ([x (car xs)] [a (* mx x)] [b (* mn x)] [new-mx (max x (max a b))] [new-mn (min x (min a b))]) (loop (cdr xs) new-mx new-mn (max best new-mx)))))

  - name: word_break_check
    inputs: ['String', 'List(String)']
    input_names: ['s', 'dict']
    output: "Boolean"
    racket_symbol: "word_break_check"
    description: "Word break: can string be segmented into dictionary words?"
    racket_body: |
      (let* ([n (string-length s)] [dp (make-vector (+ n 1) #f)]) (vector-set! dp 0 #t) (for ([i (in-range 1 (+ n 1))]) (for ([w (in-list dict)]) (let ([wl (string-length w)]) (when (and (>= i wl) (vector-ref dp (- i wl)) (string=? (substring s (- i wl) i) w)) (vector-set! dp i #t))))) (vector-ref dp n))

  # =========================================================================
  # Encoding (new)
  # =========================================================================

  - name: base64_dec
    inputs: ['String']
    input_names: ['s']
    output: "String"
    racket_symbol: "base64_dec"
    description: "Base64 decode: decode base64 string to original"
    racket_body: |
      (let* ([tbl "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"] [idx (lambda (c) (let loop ([i 0]) (if (char=? c (string-ref tbl i)) i (loop (+ i 1)))))] [clean (filter (lambda (c) (not (char=? c #\=))) (string->list s))] [bits (apply append (map (lambda (c) (let ([v (idx c)]) (for/list ([i (in-range 5 -1 -1)]) (if (> (bitwise-and v (arithmetic-shift 1 i)) 0) 1 0)))) clean))] [nbytes (quotient (* (length clean) 6) 8)]) (list->string (for/list ([i (in-range nbytes)]) (integer->char (for/fold ([v 0]) ([j (in-range 8)]) (+ (* v 2) (list-ref bits (+ (* i 8) j))))))))

  - name: morse_code_encode
    inputs: ['String']
    input_names: ['s']
    output: "String"
    racket_symbol: "morse_code_encode"
    description: "Morse code encode: convert text to morse code"
    racket_body: |
      (let ([tbl (hash #\A ".-" #\B "-..." #\C "-.-." #\D "-.." #\E "." #\F "..-." #\G "--." #\H "...." #\I ".." #\J ".---" #\K "-.-" #\L ".-.." #\M "--" #\N "-." #\O "---" #\P ".--." #\Q "--.-" #\R ".-." #\S "..." #\T "-" #\U "..-" #\V "...-" #\W ".--" #\X "-..-" #\Y "-.--" #\Z "--.." #\0 "-----" #\1 ".----" #\2 "..---" #\3 "...--" #\4 "....-" #\5 "....." #\6 "-...." #\7 "--..." #\8 "---.." #\9 "----.")]) (string-join (filter (lambda (x) (not (string=? x ""))) (map (lambda (c) (hash-ref tbl (char-upcase c) "")) (string->list s))) " "))

  # =========================================================================
  # Geometry (new)
  # =========================================================================

  - name: euclidean_distance
    inputs: ['Number', 'Number', 'Number', 'Number']
    input_names: ['x1', 'y1', 'x2', 'y2']
    output: "Number"
    racket_symbol: "euclidean_distance"
    description: "Euclidean distance between two 2D points"
    racket_body: |
      (sqrt (+ (expt (- x2 x1) 2) (expt (- y2 y1) 2)))

  - name: triangle_area
    inputs: ['Number', 'Number', 'Number', 'Number', 'Number', 'Number']
    input_names: ['x1', 'y1', 'x2', 'y2', 'x3', 'y3']
    output: "Number"
    racket_symbol: "triangle_area"
    description: "Triangle area from three vertices using cross product"
    racket_body: |
      (/ (abs (+ (* x1 (- y2 y3)) (* x2 (- y3 y1)) (* x3 (- y1 y2)))) 2)

  - name: is_point_in_circle
    inputs: ['Number', 'Number', 'Number', 'Number', 'Number']
    input_names: ['px', 'py', 'cx', 'cy', 'r']
    output: "Boolean"
    racket_symbol: "is_point_in_circle"
    description: "Check if point (px,py) is inside circle centered at (cx,cy) with radius r"
    racket_body: |
      (<= (+ (expt (- px cx) 2) (expt (- py cy) 2)) (expt r 2))

  - name: convex_hull_area
    inputs: ['List(List(Number))']
    input_names: ['points']
    output: "Number"
    racket_symbol: "convex_hull_area"
    description: "Area of convex hull of given points using shoelace formula"
    racket_body: |
      (let* ([cross (lambda (o a b) (- (* (- (car a) (car o)) (- (cadr b) (cadr o))) (* (- (cadr a) (cadr o)) (- (car b) (car o)))))] [pts (sort points (lambda (a b) (or (< (car a) (car b)) (and (= (car a) (car b)) (< (cadr a) (cadr b))))))] [build (lambda (pts) (foldl (lambda (p hull) (let loop ([h hull]) (if (and (>= (length h) 2) (<= (cross (cadr h) (car h) p) 0)) (loop (cdr h)) (cons p h)))) (list) pts))] [lower (build pts)] [upper (build (reverse pts))] [hull (append (reverse (cdr lower)) (reverse (cdr upper)))] [n (length hull)]) (/ (abs (for/sum ([i (in-range n)]) (let ([a (list-ref hull i)] [b (list-ref hull (modulo (+ i 1) n))]) (- (* (car a) (cadr b)) (* (car b) (cadr a)))))) 2))

  # =========================================================================
  # Graph (new)
  # =========================================================================

  - name: a_star_search
    inputs: ['Number']
    input_names: ['n']
    output: "List(Number)"
    racket_symbol: "a_star_search"
    description: "A* search: find shortest path using heuristic on a grid graph"
    racket_body: |
      (let* ([adj (vector '((1 . 1) (2 . 4)) '((0 . 1) (3 . 2) (2 . 2)) '((0 . 4) (1 . 2) (3 . 1)) '((1 . 2) (2 . 1) (4 . 3)) '((3 . 3)))] [h (vector 4 3 2 1 0)] [inf 999999] [dist (make-vector n inf)] [prev (make-vector n -1)]) (vector-set! dist 0 0) (let loop ([open (list (cons 0 0))]) (if (null? open) (let path ([node (- n 1)] [acc (list)]) (if (= node -1) acc (path (vector-ref prev node) (cons node acc)))) (let* ([sorted (sort open (lambda (a b) (< (+ (cdr a) (vector-ref h (car a))) (+ (cdr b) (vector-ref h (car b))))))] [cur (caar sorted)] [rest (cdr sorted)]) (if (= cur (- n 1)) (let path ([node cur] [acc (list)]) (if (= node -1) acc (path (vector-ref prev node) (cons node acc)))) (let nbr-loop ([nbrs (vector-ref adj cur)] [open rest]) (if (null? nbrs) (loop open) (let* ([nb (caar nbrs)] [w (cdar nbrs)] [nd (+ (vector-ref dist cur) w)]) (if (< nd (vector-ref dist nb)) (begin (vector-set! dist nb nd) (vector-set! prev nb cur) (nbr-loop (cdr nbrs) (cons (cons nb nd) open))) (nbr-loop (cdr nbrs) open))))))))))

  - name: bipartite_check
    inputs: ['Number']
    input_names: ['n']
    output: "Boolean"
    racket_symbol: "bipartite_check"
    description: "Bipartite check: determine if graph is 2-colorable using BFS"
    racket_body: |
      (let* ([adj (vector (list 1 3) (list 0 2) (list 1 3) (list 0 2))] [color (make-vector n -1)]) (vector-set! color 0 0) (let loop ([queue (list 0)]) (if (null? queue) #t (let* ([u (car queue)] [rest (cdr queue)] [c (vector-ref color u)]) (let nbr ([nbrs (vector-ref adj u)] [q rest]) (if (null? nbrs) (loop q) (let ([v (car nbrs)]) (cond [(= (vector-ref color v) -1) (vector-set! color v (- 1 c)) (nbr (cdr nbrs) (append q (list v)))] [(= (vector-ref color v) c) #f] [else (nbr (cdr nbrs) q)]))))))))

  - name: graph_coloring_greedy
    inputs: ['Number']
    input_names: ['n']
    output: "List(Number)"
    racket_symbol: "graph_coloring_greedy"
    description: "Greedy graph coloring: assign minimum colors to vertices"
    racket_body: |
      (let* ([adj (vector (list 1 2) (list 0 2 3) (list 0 1 3) (list 1 2 4) (list 3))] [colors (make-vector n -1)]) (for ([u (in-range n)]) (let ([used (for/fold ([s (set)]) ([v (in-list (vector-ref adj u))]) (let ([c (vector-ref colors v)]) (if (>= c 0) (set-add s c) s)))]) (let find ([c 0]) (if (set-member? used c) (find (+ c 1)) (vector-set! colors u c))))) (vector->list colors))

  - name: has_euler_path
    inputs: ['Number']
    input_names: ['n']
    output: "Boolean"
    racket_symbol: "has_euler_path"
    description: "Euler path check: does graph have an Eulerian path?"
    racket_body: |
      (let* ([adj (vector (list 1 2) (list 0 2) (list 0 1 3) (list 2))] [degrees (for/list ([i (in-range n)]) (length (vector-ref adj i)))] [odd-count (for/sum ([d (in-list degrees)]) (if (odd? d) 1 0))]) (or (= odd-count 0) (= odd-count 2)))

  - name: detect_cycle_directed
    inputs: ['Number']
    input_names: ['n']
    output: "Boolean"
    racket_symbol: "detect_cycle_directed"
    description: "Detect cycle in directed graph using DFS coloring"
    racket_body: |
      (let* ([adj (vector (list 1) (list 2) (list 3) (list 1))] [color (make-vector n 0)]) (let/ec return (for ([u (in-range n)]) (when (= (vector-ref color u) 0) (let dfs ([v u]) (vector-set! color v 1) (for ([w (in-list (vector-ref adj v))]) (cond [(= (vector-ref color w) 1) (return #t)] [(= (vector-ref color w) 0) (dfs w)])) (vector-set! color v 2)))) #f))

  - name: shortest_path_unweighted
    inputs: ['Number']
    input_names: ['n']
    output: "List(Number)"
    racket_symbol: "shortest_path_unweighted"
    description: "Shortest path in unweighted graph using BFS"
    racket_body: |
      (let* ([adj (vector (list 1 2) (list 0 3) (list 0 3 4) (list 1 2 5) (list 2 5) (list 3 4))] [dist (make-vector n -1)]) (vector-set! dist 0 0) (let loop ([queue (list 0)]) (if (null? queue) (vector->list dist) (let* ([u (car queue)] [rest (cdr queue)]) (let nbr ([nbrs (vector-ref adj u)] [q rest]) (if (null? nbrs) (loop q) (let ([v (car nbrs)]) (if (= (vector-ref dist v) -1) (begin (vector-set! dist v (+ (vector-ref dist u) 1)) (nbr (cdr nbrs) (append q (list v)))) (nbr (cdr nbrs) q)))))))))

  # =========================================================================
  # Hashing (new)
  # =========================================================================

  - name: djb2_hash
    inputs: ['String']
    input_names: ['s']
    output: "Number"
    racket_symbol: "djb2_hash"
    description: "DJB2 hash: simple string hash function by Dan Bernstein"
    racket_body: |
      (for/fold ([h 5381]) ([c (in-string s)]) (+ (* h 33) (char->integer c)))

  - name: adler32_hash
    inputs: ['String']
    input_names: ['s']
    output: "Number"
    racket_symbol: "adler32_hash"
    description: "Adler-32 checksum: fast rolling hash"
    racket_body: |
      (let ([mod 65521]) (let-values ([(a b) (for/fold ([a 1] [b 0]) ([c (in-string s)]) (let ([na (modulo (+ a (char->integer c)) mod)]) (values na (modulo (+ b na) mod))))]) (+ (* b 65536) a)))

  # =========================================================================
  # Number Theory (new)
  # =========================================================================

  - name: miller_rabin_primality
    inputs: ['Number']
    input_names: ['n']
    output: "Boolean"
    racket_symbol: "miller_rabin_primality"
    description: "Miller-Rabin primality test (deterministic for n < 3,215,031,751)"
    racket_body: |
      (cond [(< n 2) #f] [(< n 4) #t] [(even? n) #f] [else (let* ([d (let loop ([d (- n 1)]) (if (odd? d) d (loop (quotient d 2))))] [r (let loop ([r 0] [t (- n 1)]) (if (odd? t) r (loop (+ r 1) (quotient t 2))))] [mod-pow (lambda (base exp mod) (let loop ([b base] [e exp] [result 1]) (if (= e 0) result (loop (modulo (* b b) mod) (quotient e 2) (if (odd? e) (modulo (* result b) mod) result)))))]) (let witness ([as (list 2 3 5 7)]) (if (null? as) #t (let* ([a (car as)]) (if (>= a n) (witness (cdr as)) (let* ([x (mod-pow a d n)]) (if (or (= x 1) (= x (- n 1))) (witness (cdr as)) (let inner ([j 1] [x x]) (cond [(= j r) #f] [(= (modulo (* x x) n) (- n 1)) (witness (cdr as))] [else (inner (+ j 1) (modulo (* x x) n))])))))))))])

  - name: nth_prime
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "nth_prime"
    description: "Find the nth prime number (1-indexed)"
    racket_body: |
      (let* ([is-prime (lambda (x) (and (> x 1) (let loop ([i 2]) (cond [(> (* i i) x) #t] [(= (modulo x i) 0) #f] [else (loop (+ i 1))]))))]) (let loop ([x 2] [count 0]) (if (is-prime x) (if (= (+ count 1) n) x (loop (+ x 1) (+ count 1))) (loop (+ x 1) count))))

  - name: sum_of_divisors
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "sum_of_divisors"
    description: "Sum of all divisors of n (including n)"
    racket_body: |
      (for/sum ([i (in-range 1 (+ n 1))]) (if (= (modulo n i) 0) i 0))

  - name: mobius_function
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "mobius_function"
    description: "Möbius function: μ(n) = 0 if n has squared prime factor, (-1)^k otherwise"
    racket_body: |
      (if (= n 1) 1 (let loop ([x n] [d 2] [k 0]) (cond [(> (* d d) x) (if (> x 1) (* (expt -1 (+ k 1)) 1) (expt -1 k))] [(= (modulo x d) 0) (if (= (modulo (quotient x d) d) 0) 0 (loop (quotient x d) (+ d 1) (+ k 1)))] [else (loop x (+ d 1) k)])))

  - name: legendre_symbol
    inputs: ['Number', 'Number']
    input_names: ['a', 'p']
    output: "Number"
    racket_symbol: "legendre_symbol"
    description: "Legendre symbol (a/p): 0 if p|a, 1 if a is QR mod p, -1 otherwise"
    racket_body: |
      (let* ([mod-pow (lambda (base exp mod) (let loop ([b base] [e exp] [r 1]) (if (= e 0) r (loop (modulo (* b b) mod) (quotient e 2) (if (odd? e) (modulo (* r b) mod) r)))))]) (let ([r (mod-pow (modulo a p) (quotient (- p 1) 2) p)]) (if (> r 1) -1 r)))

  # =========================================================================
  # Probability (new)
  # =========================================================================

  - name: fisher_yates_shuffle
    inputs: ['List(Number)']
    input_names: ['lst']
    output: "List(Number)"
    racket_symbol: "fisher_yates_shuffle"
    description: "Fisher-Yates shuffle: random permutation (seeded for reproducibility)"
    racket_body: |
      (let* ([v (list->vector lst)] [n (vector-length v)] [rng (make-pseudo-random-generator)]) (parameterize ([current-pseudo-random-generator rng]) (random-seed 42) (for ([i (in-range (- n 1) 0 -1)]) (let ([j (random (+ i 1))]) (let ([tmp (vector-ref v i)]) (vector-set! v i (vector-ref v j)) (vector-set! v j tmp))))) (vector->list v))

  - name: birthday_paradox_sim
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "birthday_paradox_sim"
    description: "Birthday paradox: expected people for 50% collision probability in n-day year"
    racket_body: |
      (let loop ([k 1] [p 1.0]) (let ([np (* p (/ (- n k) n))]) (if (< np 0.5) (+ k 1) (loop (+ k 1) np))))

  - name: markov_chain_steady_state
    inputs: ['Number']
    input_names: ['n']
    output: "List(Number)"
    racket_symbol: "markov_chain_steady_state"
    description: "Markov chain steady state: find stationary distribution by power iteration"
    racket_body: |
      (let* ([P (vector (vector 0.7 0.3) (vector 0.4 0.6))] [state (make-vector n (/ 1.0 n))]) (for ([_ (in-range 100)]) (let ([new (make-vector n 0.0)]) (for ([j (in-range n)]) (for ([i (in-range n)]) (vector-set! new j (+ (vector-ref new j) (* (vector-ref state i) (vector-ref (vector-ref P i) j)))))) (for ([i (in-range n)]) (vector-set! state i (vector-ref new i))))) (map (lambda (x) (exact->inexact (/ (round (* x 10000)) 10000))) (vector->list state)))

  # =========================================================================
  # Searching (new)
  # =========================================================================

  - name: three_sum
    inputs: ['List(Number)']
    input_names: ['nums']
    output: "List(List(Number))"
    racket_symbol: "three_sum"
    description: "Three sum: find all triplets that sum to zero"
    racket_body: |
      (let* ([sorted (sort nums <)] [n (length sorted)] [v (list->vector sorted)]) (let outer ([i 0] [result (list)]) (if (>= i (- n 2)) (reverse result) (if (and (> i 0) (= (vector-ref v i) (vector-ref v (- i 1)))) (outer (+ i 1) result) (let inner ([lo (+ i 1)] [hi (- n 1)] [res result]) (if (>= lo hi) (outer (+ i 1) res) (let ([s (+ (vector-ref v i) (vector-ref v lo) (vector-ref v hi))]) (cond [(= s 0) (inner (+ lo 1) (- hi 1) (cons (list (vector-ref v i) (vector-ref v lo) (vector-ref v hi)) res))] [(< s 0) (inner (+ lo 1) hi res)] [else (inner lo (- hi 1) res)]))))))))

  - name: peak_element
    inputs: ['List(Number)']
    input_names: ['nums']
    output: "Number"
    racket_symbol: "peak_element"
    description: "Peak element: find index of element greater than neighbors using binary search"
    racket_body: |
      (let* ([v (list->vector nums)] [n (vector-length v)]) (let loop ([lo 0] [hi (- n 1)]) (if (= lo hi) lo (let ([mid (quotient (+ lo hi) 2)]) (if (> (vector-ref v mid) (vector-ref v (+ mid 1))) (loop lo mid) (loop (+ mid 1) hi))))))

  - name: kth_smallest
    inputs: ['List(Number)', 'Number']
    input_names: ['nums', 'k']
    output: "Number"
    racket_symbol: "kth_smallest"
    description: "Kth smallest element using quickselect"
    racket_body: |
      (let* ([sel (lambda (sel lst k) (let* ([pivot (car lst)] [lo (filter (lambda (x) (< x pivot)) (cdr lst))] [eq (filter (lambda (x) (= x pivot)) lst)] [hi (filter (lambda (x) (> x pivot)) (cdr lst))]) (cond [(<= k (length lo)) (sel sel lo k)] [(<= k (+ (length lo) (length eq))) pivot] [else (sel sel hi (- k (length lo) (length eq)))])))]) (sel sel nums k))

  # =========================================================================
  # Sorting (new)
  # =========================================================================

  - name: gnome_sort
    inputs: ['List(Number)']
    input_names: ['lst']
    output: "List(Number)"
    racket_symbol: "gnome_sort"
    description: "Gnome sort: simple exchange sort moving back and forth"
    racket_body: |
      (let* ([v (list->vector lst)] [n (vector-length v)]) (let loop ([i 0]) (if (>= i n) (vector->list v) (if (or (= i 0) (<= (vector-ref v (- i 1)) (vector-ref v i))) (loop (+ i 1)) (let ([tmp (vector-ref v i)]) (vector-set! v i (vector-ref v (- i 1))) (vector-set! v (- i 1) tmp) (loop (- i 1)))))))

  - name: cocktail_shaker_sort
    inputs: ['List(Number)']
    input_names: ['lst']
    output: "List(Number)"
    racket_symbol: "cocktail_shaker_sort"
    description: "Cocktail shaker sort: bidirectional bubble sort"
    racket_body: |
      (let* ([v (list->vector lst)] [n (vector-length v)]) (let outer ([start 0] [end (- n 1)] [swapped #t]) (if (not swapped) (vector->list v) (let fwd ([i start] [sw #f]) (if (>= i end) (let bwd ([j (- end 1)] [sw2 sw]) (if (< j start) (outer (+ start 1) (- end 1) sw2) (if (> (vector-ref v j) (vector-ref v (+ j 1))) (let ([tmp (vector-ref v j)]) (vector-set! v j (vector-ref v (+ j 1))) (vector-set! v (+ j 1) tmp) (bwd (- j 1) #t)) (bwd (- j 1) sw2)))) (if (> (vector-ref v i) (vector-ref v (+ i 1))) (let ([tmp (vector-ref v i)]) (vector-set! v i (vector-ref v (+ i 1))) (vector-set! v (+ i 1) tmp) (fwd (+ i 1) #t)) (fwd (+ i 1) sw)))))))

  - name: pancake_sort
    inputs: ['List(Number)']
    input_names: ['lst']
    output: "List(Number)"
    racket_symbol: "pancake_sort"
    description: "Pancake sort: sort by flipping prefixes"
    racket_body: |
      (let* ([v (list->vector lst)] [n (vector-length v)] [flip (lambda (v end) (let loop ([i 0] [j end]) (when (< i j) (let ([tmp (vector-ref v i)]) (vector-set! v i (vector-ref v j)) (vector-set! v j tmp) (loop (+ i 1) (- j 1))))))]) (for ([size (in-range (- n 1) 0 -1)]) (let ([mi (let loop ([i 0] [best 0]) (if (> i size) best (loop (+ i 1) (if (> (vector-ref v i) (vector-ref v best)) i best))))]) (when (not (= mi size)) (flip v mi) (flip v size)))) (vector->list v))

  # =========================================================================
  # String (new)
  # =========================================================================

  - name: z_algorithm
    inputs: ['String']
    input_names: ['s']
    output: "List(Number)"
    racket_symbol: "z_algorithm"
    description: "Z-algorithm: compute Z-array for string matching"
    racket_body: |
      (let* ([n (string-length s)] [z (make-vector n 0)]) (vector-set! z 0 n) (let loop ([i 1] [l 0] [r 0]) (when (< i n) (let* ([z-val (if (< i r) (min (vector-ref z (- i l)) (- r i)) 0)]) (let extend ([k z-val]) (if (and (< (+ i k) n) (char=? (string-ref s k) (string-ref s (+ i k)))) (extend (+ k 1)) (begin (vector-set! z i k) (when (> (+ i k) r) (loop (+ i 1) i (+ i k))) (when (<= (+ i k) r) (loop (+ i 1) l r)))))))) (vector->list z))

  - name: suffix_array
    inputs: ['String']
    input_names: ['s']
    output: "List(Number)"
    racket_symbol: "suffix_array"
    description: "Suffix array: sorted array of all suffix indices"
    racket_body: |
      (let* ([n (string-length s)] [indices (build-list n values)]) (sort indices (lambda (i j) (string<? (substring s i) (substring s j)))))

  - name: longest_repeating_substring
    inputs: ['String']
    input_names: ['s']
    output: "String"
    racket_symbol: "longest_repeating_substring"
    description: "Longest repeating substring using suffix array"
    racket_body: |
      (let* ([n (string-length s)] [sa (sort (build-list n values) (lambda (i j) (string<? (substring s i) (substring s j))))] [lcp (lambda (i j) (let loop ([k 0]) (if (and (< (+ i k) n) (< (+ j k) n) (char=? (string-ref s (+ i k)) (string-ref s (+ j k)))) (loop (+ k 1)) k)))]) (let loop ([i 1] [best ""] [bl 0]) (if (>= i n) best (let* ([l (lcp (list-ref sa (- i 1)) (list-ref sa i))]) (if (> l bl) (loop (+ i 1) (substring s (list-ref sa i) (+ (list-ref sa i) l)) l) (loop (+ i 1) best bl))))))

  - name: is_anagram
    inputs: ['String', 'String']
    input_names: ['a', 'b']
    output: "Boolean"
    racket_symbol: "is_anagram"
    description: "Anagram check: do two strings have the same character frequencies?"
    racket_body: |
      (equal? (sort (string->list a) char<?) (sort (string->list b) char<?))

  - name: string_reverse
    inputs: ['String']
    input_names: ['s']
    output: "String"
    racket_symbol: "string_reverse"
    description: "String reverse: reverse a string"
    racket_body: |
      (list->string (reverse (string->list s)))

  - name: longest_palindromic_substring
    inputs: ['String']
    input_names: ['s']
    output: "String"
    racket_symbol: "longest_palindromic_substring"
    description: "Longest palindromic substring using expand-around-center"
    racket_body: |
      (let* ([n (string-length s)] [expand (lambda (l r) (let loop ([l l] [r r]) (if (and (>= l 0) (< r n) (char=? (string-ref s l) (string-ref s r))) (loop (- l 1) (+ r 1)) (substring s (+ l 1) r))))]) (let loop ([i 0] [best ""]) (if (>= i n) best (let* ([p1 (expand i i)] [p2 (expand i (+ i 1))] [longest (if (> (string-length p1) (string-length p2)) p1 p2)]) (loop (+ i 1) (if (> (string-length longest) (string-length best)) longest best))))))

  # =========================================================================
  # Matrix (new category)
  # =========================================================================

  - name: matrix_transpose
    inputs: ['List(List(Number))']
    input_names: ['mat']
    output: "List(List(Number))"
    racket_symbol: "matrix_transpose"
    description: "Matrix transpose: swap rows and columns"
    racket_body: |
      (apply map list mat)

  - name: matrix_multiply
    inputs: ['List(List(Number))', 'List(List(Number))']
    input_names: ['a', 'b']
    output: "List(List(Number))"
    racket_symbol: "matrix_multiply"
    description: "Matrix multiplication: A × B"
    racket_body: |
      (let ([bt (apply map list b)]) (map (lambda (row) (map (lambda (col) (apply + (map * row col))) bt)) a))

  - name: matrix_determinant
    inputs: ['List(List(Number))']
    input_names: ['mat']
    output: "Number"
    racket_symbol: "matrix_determinant"
    description: "Matrix determinant using cofactor expansion"
    racket_body: |
      (let* ([det (lambda (det m) (let ([n (length m)]) (if (= n 1) (caar m) (for/sum ([j (in-range n)]) (* (list-ref (car m) j) (expt -1 j) (det det (map (lambda (row) (append (take row j) (drop row (+ j 1)))) (cdr m))))))))]) (det det mat))

  - name: matrix_scalar_multiply
    inputs: ['List(List(Number))', 'Number']
    input_names: ['mat', 'k']
    output: "List(List(Number))"
    racket_symbol: "matrix_scalar_multiply"
    description: "Matrix scalar multiplication: k × M"
    racket_body: |
      (map (lambda (row) (map (lambda (x) (* k x)) row)) mat)

  - name: matrix_add
    inputs: ['List(List(Number))', 'List(List(Number))']
    input_names: ['a', 'b']
    output: "List(List(Number))"
    racket_symbol: "matrix_add"
    description: "Matrix addition: A + B"
    racket_body: |
      (map (lambda (ra rb) (map + ra rb)) a b)

  - name: matrix_identity
    inputs: ['Number']
    input_names: ['n']
    output: "List(List(Number))"
    racket_symbol: "matrix_identity"
    description: "Identity matrix of size n×n"
    racket_body: |
      (build-list n (lambda (i) (build-list n (lambda (j) (if (= i j) 1 0)))))

  - name: matrix_trace
    inputs: ['List(List(Number))']
    input_names: ['mat']
    output: "Number"
    racket_symbol: "matrix_trace"
    description: "Matrix trace: sum of diagonal elements"
    racket_body: |
      (for/sum ([i (in-range (length mat))]) (list-ref (list-ref mat i) i))

  - name: matrix_power
    inputs: ['List(List(Number))', 'Number']
    input_names: ['mat', 'k']
    output: "List(List(Number))"
    racket_symbol: "matrix_power"
    description: "Matrix exponentiation: M^k using repeated squaring"
    racket_body: |
      (let* ([n (length mat)] [mul (lambda (a b) (let ([bt (apply map list b)]) (map (lambda (row) (map (lambda (col) (apply + (map * row col))) bt)) a)))] [eye (build-list n (lambda (i) (build-list n (lambda (j) (if (= i j) 1 0)))))]) (let loop ([base mat] [exp k] [result eye]) (cond [(= exp 0) result] [(odd? exp) (loop (mul base base) (quotient exp 2) (mul result base))] [else (loop (mul base base) (quotient exp 2) result)])))

  # =========================================================================
  # Backtracking (new category)
  # =========================================================================

  - name: n_queens
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "n_queens"
    description: "N-Queens: count solutions for placing n non-attacking queens"
    racket_body: |
      (let* ([solve (lambda (solve cols diag1 diag2 row) (if (= row n) 1 (for/sum ([col (in-range n)]) (if (and (not (set-member? cols col)) (not (set-member? diag1 (- row col))) (not (set-member? diag2 (+ row col)))) (solve solve (set-add cols col) (set-add diag1 (- row col)) (set-add diag2 (+ row col)) (+ row 1)) 0))))]) (solve solve (set) (set) (set) 0))

  - name: sudoku_solver
    inputs: ['List(List(Number))']
    input_names: ['board']
    output: "List(List(Number))"
    racket_symbol: "sudoku_solver"
    description: "Sudoku solver: fill 9×9 grid (0 = empty) using backtracking"
    racket_body: |
      (let* ([grid (for/vector ([row (in-list board)]) (list->vector row))] [valid? (lambda (r c v) (and (for/and ([j (in-range 9)]) (not (= (vector-ref (vector-ref grid r) j) v))) (for/and ([i (in-range 9)]) (not (= (vector-ref (vector-ref grid i) c) v))) (let ([br (* 3 (quotient r 3))] [bc (* 3 (quotient c 3))]) (for/and ([i (in-range br (+ br 3))]) (for/and ([j (in-range bc (+ bc 3))]) (not (= (vector-ref (vector-ref grid i) j) v)))))))] [solve (lambda (solve) (let/ec return (for ([r (in-range 9)]) (for ([c (in-range 9)]) (when (= (vector-ref (vector-ref grid r) c) 0) (for ([v (in-range 1 10)]) (when (valid? r c v) (vector-set! (vector-ref grid r) c v) (when (solve solve) (return #t)) (vector-set! (vector-ref grid r) c 0))) (return #f)))) #t))]) (solve solve) (for/list ([r (in-range 9)]) (vector->list (vector-ref grid r))))

  - name: generate_parentheses
    inputs: ['Number']
    input_names: ['n']
    output: "List(String)"
    racket_symbol: "generate_parentheses"
    description: "Generate all valid combinations of n pairs of parentheses"
    racket_body: |
      (let* ([gen (lambda (gen open close current) (if (and (= open n) (= close n)) (list current) (append (if (< open n) (gen gen (+ open 1) close (string-append current "(")) (list)) (if (< close open) (gen gen open (+ close 1) (string-append current ")")) (list)))))]) (gen gen 0 0 ""))

  - name: permutations_with_duplicates
    inputs: ['List(Number)']
    input_names: ['nums']
    output: "List(List(Number))"
    racket_symbol: "permutations_with_duplicates"
    description: "Unique permutations of a list that may contain duplicates"
    racket_body: |
      (let* ([sorted (sort nums <)] [perm (lambda (perm lst) (if (null? lst) (list (list)) (let loop ([prev #f] [rest lst] [skipped (list)] [result (list)]) (if (null? rest) result (let ([x (car rest)]) (if (equal? x prev) (loop prev (cdr rest) (cons x skipped) result) (let ([sub (perm perm (append (reverse skipped) (cdr rest)))]) (loop x (cdr rest) (cons x skipped) (append result (map (lambda (p) (cons x p)) sub))))))))))]) (perm perm sorted))

  - name: word_search_grid
    inputs: ['String']
    input_names: ['word']
    output: "Boolean"
    racket_symbol: "word_search_grid"
    description: "Word search: find word in a 2D character grid"
    racket_body: |
      (let* ([grid (vector (vector #\A #\B #\C #\E) (vector #\S #\F #\C #\S) (vector #\A #\D #\E #\E))] [rows 3] [cols 4] [wlen (string-length word)] [visited (for/vector ([_ (in-range rows)]) (make-vector cols #f))] [dfs (lambda (dfs r c k) (cond [(= k wlen) #t] [(or (< r 0) (>= r rows) (< c 0) (>= c cols)) #f] [(vector-ref (vector-ref visited r) c) #f] [(not (char=? (vector-ref (vector-ref grid r) c) (string-ref word k))) #f] [else (vector-set! (vector-ref visited r) c #t) (let ([found (or (dfs dfs (+ r 1) c (+ k 1)) (dfs dfs (- r 1) c (+ k 1)) (dfs dfs r (+ c 1) (+ k 1)) (dfs dfs r (- c 1) (+ k 1)))]) (vector-set! (vector-ref visited r) c #f) found)]))]) (let/ec return (for ([r (in-range rows)]) (for ([c (in-range cols)]) (when (dfs dfs r c 0) (return #t)))) #f))

  - name: subset_sum_all
    inputs: ['List(Number)', 'Number']
    input_names: ['nums', 'target']
    output: "List(List(Number))"
    racket_symbol: "subset_sum_all"
    description: "Find all subsets that sum to target"
    racket_body: |
      (let* ([find (lambda (find idx current sum) (cond [(= sum target) (list (reverse current))] [(or (>= idx (length nums)) (> sum target)) (list)] [else (let ([x (list-ref nums idx)]) (append (find find (+ idx 1) (cons x current) (+ sum x)) (find find (+ idx 1) current sum)))]))]) (find find 0 (list) 0))

  # =========================================================================
  # Interval (new category)
  # =========================================================================

  - name: merge_intervals
    inputs: ['List(List(Number))']
    input_names: ['intervals']
    output: "List(List(Number))"
    racket_symbol: "merge_intervals"
    description: "Merge overlapping intervals"
    racket_body: |
      (let* ([sorted (sort intervals (lambda (a b) (< (car a) (car b))))]) (foldl (lambda (iv acc) (if (and (not (null? acc)) (>= (cadr (car acc)) (car iv))) (cons (list (car (car acc)) (max (cadr (car acc)) (cadr iv))) (cdr acc)) (cons iv acc))) (list) sorted))

  - name: interval_intersection
    inputs: ['List(List(Number))', 'List(List(Number))']
    input_names: ['a', 'b']
    output: "List(List(Number))"
    racket_symbol: "interval_intersection"
    description: "Intersection of two lists of sorted intervals"
    racket_body: |
      (let loop ([a a] [b b] [result (list)]) (if (or (null? a) (null? b)) (reverse result) (let* ([lo (max (caar a) (caar b))] [hi (min (cadar a) (cadar b))]) (let ([res (if (<= lo hi) (cons (list lo hi) result) result)]) (if (< (cadar a) (cadar b)) (loop (cdr a) b res) (loop a (cdr b) res))))))

  - name: interval_scheduling_max
    inputs: ['List(List(Number))']
    input_names: ['intervals']
    output: "Number"
    racket_symbol: "interval_scheduling_max"
    description: "Maximum non-overlapping intervals (activity selection)"
    racket_body: |
      (let* ([sorted (sort intervals (lambda (a b) (< (cadr a) (cadr b))))]) (let loop ([ivs sorted] [end -1] [count 0]) (if (null? ivs) count (if (>= (caar ivs) end) (loop (cdr ivs) (cadar ivs) (+ count 1)) (loop (cdr ivs) end count)))))

  - name: insert_interval
    inputs: ['List(List(Number))', 'List(Number)']
    input_names: ['intervals', 'new_iv']
    output: "List(List(Number))"
    racket_symbol: "insert_interval"
    description: "Insert interval into sorted non-overlapping list, merging as needed"
    racket_body: |
      (let loop ([ivs intervals] [lo (car new_iv)] [hi (cadr new_iv)] [left (list)] [merged #f]) (if (null? ivs) (reverse (cons (list lo hi) left)) (let ([cur (car ivs)]) (cond [(< (cadr cur) lo) (loop (cdr ivs) lo hi (cons cur left) merged)] [(> (car cur) hi) (append (reverse left) (list (list lo hi)) ivs)] [else (loop (cdr ivs) (min lo (car cur)) (max hi (cadr cur)) left #t)]))))

  # =========================================================================
  # Tree (new category)
  # =========================================================================

  - name: tree_inorder
    inputs: ['List(Any)']
    input_names: ['tree']
    output: "List(Number)"
    racket_symbol: "tree_inorder"
    description: "Binary tree inorder traversal (tree = (val left right) or null)"
    racket_body: |
      (let* ([inorder (lambda (inorder t) (if (null? t) (list) (append (inorder inorder (cadr t)) (list (car t)) (inorder inorder (caddr t)))))]) (inorder inorder tree))

  - name: tree_preorder
    inputs: ['List(Any)']
    input_names: ['tree']
    output: "List(Number)"
    racket_symbol: "tree_preorder"
    description: "Binary tree preorder traversal"
    racket_body: |
      (let* ([preorder (lambda (preorder t) (if (null? t) (list) (append (list (car t)) (preorder preorder (cadr t)) (preorder preorder (caddr t)))))]) (preorder preorder tree))

  - name: tree_postorder
    inputs: ['List(Any)']
    input_names: ['tree']
    output: "List(Number)"
    racket_symbol: "tree_postorder"
    description: "Binary tree postorder traversal"
    racket_body: |
      (let* ([postorder (lambda (postorder t) (if (null? t) (list) (append (postorder postorder (cadr t)) (postorder postorder (caddr t)) (list (car t)))))]) (postorder postorder tree))

  - name: tree_height
    inputs: ['List(Any)']
    input_names: ['tree']
    output: "Number"
    racket_symbol: "tree_height"
    description: "Binary tree height (max depth)"
    racket_body: |
      (let* ([height (lambda (height t) (if (null? t) 0 (+ 1 (max (height height (cadr t)) (height height (caddr t))))))]) (height height tree))

  - name: tree_level_order
    inputs: ['List(Any)']
    input_names: ['tree']
    output: "List(List(Number))"
    racket_symbol: "tree_level_order"
    description: "Binary tree level-order (BFS) traversal"
    racket_body: |
      (let loop ([queue (if (null? tree) (list) (list tree))] [result (list)]) (if (null? queue) (reverse result) (let-values ([(level next) (let lv ([q queue] [vals (list)] [nxt (list)]) (if (null? q) (values (reverse vals) (reverse nxt)) (let ([node (car q)]) (lv (cdr q) (cons (car node) vals) (let ([n nxt]) (let ([n (if (null? (cadr node)) n (cons (cadr node) n))]) (if (null? (caddr node)) n (cons (caddr node) n))))))))]) (loop next (cons level result)))))

  - name: tree_mirror
    inputs: ['List(Any)']
    input_names: ['tree']
    output: "List(Any)"
    racket_symbol: "tree_mirror"
    description: "Mirror/invert a binary tree"
    racket_body: |
      (let* ([mirror (lambda (mirror t) (if (null? t) (list) (list (car t) (mirror mirror (caddr t)) (mirror mirror (cadr t)))))]) (mirror mirror tree))

  - name: lowest_common_ancestor
    inputs: ['List(Any)', 'Number', 'Number']
    input_names: ['tree', 'p', 'q']
    output: "Number"
    racket_symbol: "lowest_common_ancestor"
    description: "Lowest common ancestor in a binary tree"
    racket_body: |
      (let* ([lca (lambda (lca t p q) (cond [(null? t) -1] [(or (= (car t) p) (= (car t) q)) (car t)] [else (let ([left (lca lca (cadr t) p q)] [right (lca lca (caddr t) p q)]) (cond [(and (not (= left -1)) (not (= right -1))) (car t)] [(not (= left -1)) left] [else right]))]))]) (lca lca tree p q))

  - name: tree_diameter
    inputs: ['List(Any)']
    input_names: ['tree']
    output: "Number"
    racket_symbol: "tree_diameter"
    description: "Binary tree diameter: longest path between any two nodes"
    racket_body: |
      (let* ([best (box 0)] [height (lambda (height t) (if (null? t) 0 (let ([lh (height height (cadr t))] [rh (height height (caddr t))]) (set-box! best (max (unbox best) (+ lh rh))) (+ 1 (max lh rh)))))]) (height height tree) (unbox best))

  - name: is_balanced_tree
    inputs: ['List(Any)']
    input_names: ['tree']
    output: "Boolean"
    racket_symbol: "is_balanced_tree"
    description: "Check if binary tree is height-balanced"
    racket_body: |
      (let* ([check (lambda (check t) (if (null? t) 0 (let ([lh (check check (cadr t))] [rh (check check (caddr t))]) (if (or (= lh -1) (= rh -1) (> (abs (- lh rh)) 1)) -1 (+ 1 (max lh rh))))))]) (not (= (check check tree) -1)))

  - name: is_valid_bst
    inputs: ['List(Any)']
    input_names: ['tree']
    output: "Boolean"
    racket_symbol: "is_valid_bst"
    description: "Check if binary tree is a valid BST"
    racket_body: |
      (let* ([valid (lambda (valid t lo hi) (if (null? t) #t (let ([v (car t)]) (and (> v lo) (< v hi) (valid valid (cadr t) lo v) (valid valid (caddr t) v hi)))))]) (valid valid tree -inf.0 +inf.0))

  # =========================================================================
  # Extracted from multi-step YAML plans
  # =========================================================================

  - name: integer_partition_count
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "integer-partition-count"
    description: "Integer partition count: number of ways to write n as sum of positive integers"
    racket_body: |
      (let* ( [step-1 (+ n 1)] [step-2 (make-vector step-1 0)] [step-3 (vector-set! step-2 0 1)] [step-4 (range 1 (+ n 1))] [step-5 (for-each (lambda (i) (for ([j (in-range i (+ n 1))]) (let* ([body-1 (vector-ref step-2 j)] [body-2 (- j i)] [body-3 (vector-ref step-2 body-2)] [body-4 (+ body-1 body-3)] [body-5 (vector-set! step-2 j body-4)]) body-5))) step-4)] [step-6 (vector-ref step-2 n)] ) step-6)

  - name: pascals_triangle_row
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "pascals-triangle-row"
    description: "Pascal's triangle row: row n (0-indexed)"
    racket_body: |
      (let* ( [step-1 (range 1 (+ n 1))] [step-2 (for/fold ([row (list 1)]) ([i (in-list step-1)]) (let* ([body-1 (- i 1)] [body-2 (list-ref row body-1)] [body-3 (- n i)] [body-4 (+ body-3 1)] [body-5 (* body-2 body-4)] [body-6 (quotient body-5 i)] [body-7 (list body-6)] [body-8 (append row body-7)]) body-8))] ) step-2)

  - name: triangular_number
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "triangular-number"
    description: "Triangular number: T(n) = n*(n+1)/2"
    racket_body: |
      (let* ( [step-1 (range 1 (+ n 1))] [step-2 (for/sum ([i (in-list step-1)]) i)] ) step-2)

  - name: bit_reversal
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "bit-reversal"
    description: "Bit reversal: reverse bits of 8-bit number"
    racket_body: |
      (let* ( [step-1 (range 0 8)] [step-2 (for/fold ([result 0]) ([i (in-list step-1)]) (let* ([body-1 (arithmetic-shift n (- 0 i))] [body-2 (bitwise-and body-1 1)] [body-3 (arithmetic-shift result 1)] [body-4 (bitwise-ior body-3 body-2)]) body-4))] ) step-2)

  - name: gray_code
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "gray-code"
    description: "Gray code: generate n-bit Gray code sequence"
    racket_body: |
      (let* ( [step-1 (expt 2 n)] [step-2 (for/list ([i (in-range 0 step-1)]) (bitwise-xor i (arithmetic-shift i -1)))] ) step-2)

  - name: single_number_xor
    inputs: ['List(Number)']
    input_names: ['lst']
    output: "Number"
    racket_symbol: "single-number-xor"
    description: "Single number: find element appearing once (others appear twice)"
    racket_body: |
      (for/fold ([result 0]) ([x (in-list lst)]) (bitwise-xor result x))

  - name: xor_sum
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "xor-sum"
    description: "XOR sum: XOR of all integers from 1 to n"
    racket_body: |
      (let* ( [step-1 (range 1 (+ n 1))] [step-2 (for/fold ([result 0]) ([i (in-list step-1)]) (bitwise-xor result i))] ) step-2)

  - name: catalan_number
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "catalan-number"
    description: "Catalan number: C(n) = C(2n,n)/(n+1)"
    racket_body: |
      (let* ( [step-1 (range 0 n)] [step-2 (for/fold ([r 1]) ([i (in-list step-1)]) (let* ([body-1 (* 2 n)] [body-2 (- body-1 i)] [body-3 (* r body-2)] [body-4 (+ i 1)] [body-5 (quotient body-3 body-4)]) body-5))] [step-3 (+ n 1)] [step-4 (quotient step-2 step-3)] ) step-4)

  - name: n_choose_k
    inputs: ['Number', 'Number']
    input_names: ['n', 'k']
    output: "Number"
    racket_symbol: "n-choose-k"
    description: "Binomial coefficient: C(n,k) = n! / (k! * (n-k)!)"
    racket_body: |
      (let* ( [step-1 (range 0 k)] [step-2 (for/fold ([result 1]) ([i (in-list step-1)]) (let* ([body-1 (- n i)] [body-2 (* result body-1)] [body-3 (+ i 1)] [body-4 (quotient body-2 body-3)]) body-4))] ) step-2)

  - name: permutation_count
    inputs: ['Number', 'Number']
    input_names: ['n', 'k']
    output: "Number"
    racket_symbol: "permutation-count"
    description: "Permutation count: P(n,k) = n! / (n-k)!"
    racket_body: |
      (let* ( [step-1 (- n k)] [step-2 (range step-1 n)] [step-3 (for/product ([i (in-list step-2)]) (+ i 1))] ) step-3)

  - name: power_set
    inputs: ['List(Number)']
    input_names: ['lst']
    output: "Number"
    racket_symbol: "power-set"
    description: "Power set: all subsets of a set"
    racket_body: |
      (let* ( [step-1 (length lst)] [step-2 (expt 2 step-1)] [step-3 (range 0 step-2)] [step-4 (map (lambda (mask) (let* ([body-1 (range 0 step-1)] [body-2 (for/fold ([subset (list)]) ([i (in-list body-1)]) (let* ([body-1 (arithmetic-shift 1 i)] [body-2 (bitwise-and mask body-1)] [body-3 (cond [(> body-2 0) (let* ([body-1 (list-ref lst i)] [body-2 (append subset (list body-1))]) body-2)] [else subset])]) body-3))]) body-2)) step-3)] ) step-4)

  - name: skip_list
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "skip-list"
    description: "Skip list: insert elements and check membership"
    racket_body: |
      (let* ( [step-1 (list 3 6 7 9 12)] [step-2 (sort step-1 <)] [step-3 (member 7 step-2)] [step-4 (cond [step-3 #t] [else #f])] [step-5 (member 5 step-2)] [step-6 (cond [step-5 #t] [else #f])] [step-7 (list step-4 step-6)] ) step-7)

  - name: trie_prefix_tree
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "trie-prefix-tree"
    description: "Trie: insert words and count those with given prefix"
    racket_body: |
      (let* ( [step-1 (list "apple" "app" "ape" "bat" "bar")] [step-2 (for/sum ([w (in-list step-1)]) (let* ([body-1 (string-length w)] [body-2 (cond [(and (>= body-1 2) (string=? (substring w 0 2) "ap")) 1] [else 0])]) body-2))] ) step-2)

  - name: coin_change
    inputs: ['Number']
    input_names: ['amount']
    output: "Number"
    racket_symbol: "coin-change"
    description: "Coin change: minimum coins to make amount"
    racket_body: |
      (let* ( [step-1 (+ amount 1)] [step-2 (make-vector step-1 (+ amount 1))] [step-3 (vector-set! step-2 0 0)] [step-4 (list 1 5 10 25)] [step-5 (for-each (lambda (c) (for ([a (in-range c (+ amount 1))]) (let* ([body-1 (vector-ref step-2 a)] [body-2 (- a c)] [body-3 (vector-ref step-2 body-2)] [body-4 (+ body-3 1)] [body-5 (min body-1 body-4)] [body-6 (vector-set! step-2 a body-5)]) body-6))) step-4)] [step-6 (vector-ref step-2 amount)] ) step-6)

  - name: rod_cutting
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "rod-cutting"
    description: "Rod cutting: maximum revenue from cutting rod of length n"
    racket_body: |
      (let* ( [step-1 (vector 0 1 5 8 9 10 17 17 20)] [step-2 (+ n 1)] [step-3 (make-vector step-2 0)] [step-4 (for ([i (in-range 1 (+ n 1))]) (for ([j (in-range 1 (+ i 1))]) (let* ([body-1 (vector-ref step-3 i)] [body-2 (vector-ref step-1 j)] [body-3 (- i j)] [body-4 (vector-ref step-3 body-3)] [body-5 (+ body-2 body-4)] [body-6 (max body-1 body-5)] [body-7 (vector-set! step-3 i body-6)]) body-7)))] [step-5 (vector-ref step-3 n)] ) step-5)

  - name: subset_sum
    inputs: ['Number']
    input_names: ['target']
    output: "Number"
    racket_symbol: "subset-sum"
    description: "Subset sum: can a subset sum to target?"
    racket_body: |
      (let* ( [step-1 (list 3 34 4 12 5 2)] [step-2 (+ target 1)] [step-3 (make-vector step-2 #f)] [step-4 (vector-set! step-3 0 #t)] [step-5 (for-each (lambda (x) (for ([j (in-range target (- x 1) -1)]) (let* ([body-1 (- j x)] [body-2 (vector-ref step-3 body-1)] [body-3 (when body-2 (vector-set! step-3 j #t))]) body-3))) step-1)] [step-6 (vector-ref step-3 target)] ) step-6)

  - name: zero_one_knapsack
    inputs: ['Number']
    input_names: ['capacity']
    output: "Number"
    racket_symbol: "zero-one-knapsack"
    description: "0/1 Knapsack: maximize value within weight capacity"
    racket_body: |
      (let* ( [step-1 (vector 1 3 4 5)] [step-2 (vector 1 4 5 7)] [step-3 (vector-length step-1)] [step-4 (+ capacity 1)] [step-5 (make-vector step-4 0)] [step-6 (for ([i (in-range 0 step-3)]) (for ([w (in-range capacity (- (vector-ref step-1 i) 1) -1)]) (let* ([body-1 (vector-ref step-5 w)] [body-2 (vector-ref step-1 i)] [body-3 (- w body-2)] [body-4 (vector-ref step-5 body-3)] [body-5 (vector-ref step-2 i)] [body-6 (+ body-4 body-5)] [body-7 (max body-1 body-6)] [body-8 (vector-set! step-5 w body-7)]) body-8)))] [step-7 (vector-ref step-5 capacity)] ) step-7)

  - name: closest_pair_of_points
    inputs: ['List(Any)']
    input_names: ['pts']
    output: "Number"
    racket_symbol: "closest-pair-of-points"
    description: "Closest pair of points: minimum distance between any two points"
    racket_body: |
      (let* ( [step-1 (length pts)] [step-2 (box step-1)] [step-3 (for* ([i (in-range 0 step-1)] [j (in-range (+ i 1) step-1)]) (let* ([body-1 (list-ref pts i)] [body-2 (list-ref pts j)] [body-3 (car body-1)] [body-4 (car body-2)] [body-5 (- body-3 body-4)] [body-6 (cdr body-1)] [body-7 (cdr body-2)] [body-8 (- body-6 body-7)] [body-9 (* body-5 body-5)] [body-10 (* body-8 body-8)] [body-11 (+ body-9 body-10)] [body-12 (sqrt body-11)] [body-13 (when (< body-12 (unbox step-2)) (set-box! step-2 body-12))]) body-13))] [step-4 (unbox step-2)] ) step-4)

  - name: point_in_polygon
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "point-in-polygon"
    description: "Point in polygon: ray casting algorithm"
    racket_body: |
      (let* ( [step-1 (vector 0 4 4 0)] [step-2 (vector 0 0 4 4)] [step-3 (range 0 n)] [step-4 (for/sum ([i (in-list step-3)]) (let* ([body-1 (+ i 1)] [body-2 (modulo body-1 n)] [body-3 (vector-ref step-1 i)] [body-4 (vector-ref step-2 i)] [body-5 (vector-ref step-1 body-2)] [body-6 (vector-ref step-2 body-2)] [body-7 (cond [(and (or (and (<= body-4 1) (> body-6 1)) (and (<= body-6 1) (> body-4 1))) (< 1 (+ body-3 (/ (* (- 1 body-4) (- body-5 body-3)) (- body-6 body-4))))) 1] [else 0])]) body-7))] [step-5 (odd? step-4)] ) step-5)

  - name: shoelace_polygon_area
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "shoelace-polygon-area"
    description: "Shoelace formula: area of polygon given vertices"
    racket_body: |
      (let* ( [step-1 (vector 0 4 0)] [step-2 (vector 0 0 3)] [step-3 (range 0 n)] [step-4 (for/sum ([i (in-list step-3)]) (let* ([body-1 (+ i 1)] [body-2 (modulo body-1 n)] [body-3 (vector-ref step-1 i)] [body-4 (vector-ref step-2 body-2)] [body-5 (* body-3 body-4)] [body-6 (vector-ref step-1 body-2)] [body-7 (vector-ref step-2 i)] [body-8 (* body-6 body-7)] [body-9 (- body-5 body-8)]) body-9))] [step-5 (abs step-4)] [step-6 (quotient step-5 2)] ) step-6)

  - name: bellman_ford
    inputs: ['Number', 'List(List(Number))']
    input_names: ['n', 'edges']
    output: "Number"
    racket_symbol: "bellman-ford"
    description: "Bellman-Ford: shortest paths with negative edges"
    racket_body: |
      (let* ( [step-1 (make-vector n +inf.0)] [step-2 (vector-set! step-1 0 0)] [step-3 (- n 1)] [step-4 (range 0 step-3)] [step-5 (for-each (lambda (_) (for-each (lambda (e) (let* ([body-1 (first e)] [body-2 (second e)] [body-3 (third e)] [body-4 (vector-ref step-1 body-1)] [body-5 (+ body-4 body-3)] [body-6 (vector-ref step-1 body-2)] [body-7 (when (< body-5 body-6) (vector-set! step-1 body-2 body-5))]) body-7)) edges)) step-4)] [step-6 (vector->list step-1)] ) step-6)

  - name: floyd_warshall
    inputs: ['Number', 'Vector(Vector(Number))']
    input_names: ['n', 'd']
    output: "Number"
    racket_symbol: "floyd-warshall"
    description: "Floyd-Warshall: all-pairs shortest paths"
    racket_body: |
      (let* ( [step-1 (for* ([k (in-range 0 n)] [i (in-range 0 n)] [j (in-range 0 n)]) (let* ([body-1 (vector-ref d i)] [body-2 (vector-ref body-1 k)] [body-3 (vector-ref d k)] [body-4 (vector-ref body-3 j)] [body-5 (+ body-2 body-4)] [body-6 (vector-ref body-1 j)] [body-7 (when (< body-5 body-6) (vector-set! body-1 j body-5))]) body-7))] [step-2 (vector-ref d 0)] [step-3 (vector->list step-2)] ) step-3)

  - name: prim_mst
    inputs: ['Number', 'Vector(List(Any))']
    input_names: ['n', 'adj']
    output: "Number"
    racket_symbol: "prim-mst"
    description: "Prim's MST: minimum spanning tree using greedy approach"
    racket_body: |
      (let* ( [step-1 (make-vector 4 #f)] [step-2 (make-vector 4 +inf.0)] [step-3 (vector-set! step-2 0 0)] [step-4 (range 0 n)] [step-5 (for/sum ([_ (in-list step-4)]) (let* ([body-1 (range 0 n)] [body-2 (for/fold ([best -1]) ([i (in-list body-1)]) (let* ([body-1 (vector-ref step-1 i)] [body-2 (not body-1)] [body-3 (cond [body-2 (cond [(equal? best -1) i] [(< (vector-ref step-2 i) (vector-ref step-2 best)) i] [else best])] [else best])]) body-3))] [body-3 (vector-set! step-1 body-2 #t)] [body-4 (vector-ref adj body-2)] [body-5 (for-each (lambda (edge) (let* ([body-1 (car edge)] [body-2 (cdr edge)] [body-3 (vector-ref step-1 body-1)] [body-4 (not body-3)] [body-5 (vector-ref step-2 body-1)] [body-6 (< body-2 body-5)] [body-7 (and body-4 body-6)] [body-8 (when body-7 (vector-set! step-2 body-1 body-2))]) body-8)) body-4)] [body-6 (vector-ref step-2 body-2)]) body-6))] ) step-5)

  - name: consistent_hashing
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "consistent-hashing"
    description: "Consistent hashing: assign keys to nodes on a ring"
    racket_body: |
      (let* ( [step-1 (list 100 200 300)] [step-2 (sort step-1 <)] [step-3 (for/fold ([result -1]) ([node (in-list step-2)]) (cond [(and (equal? result -1) (>= node 150)) node] [else result]))] [step-4 (cond [(equal? step-3 -1) (first step-2)] [else step-3])] ) step-4)

  - name: fnv1a_hash
    inputs: ['String']
    input_names: ['s']
    output: "Number"
    racket_symbol: "fnv1a-hash"
    description: "FNV-1a hash (32-bit)"
    racket_body: |
      (let* ( [step-1 (string->list s)] [step-2 (for/fold ([hash 2166136261]) ([c (in-list step-1)]) (let* ([body-1 (char->integer c)] [body-2 (bitwise-xor hash body-1)] [body-3 (* body-2 16777619)] [body-4 (modulo body-3 4294967296)]) body-4))] ) step-2)

  - name: murmurhash3
    inputs: ['String']
    input_names: ['s']
    output: "Number"
    racket_symbol: "murmurhash3"
    description: "MurmurHash3 (simplified 32-bit)"
    racket_body: |
      (let* ( [step-1 (string->list s)] [step-2 (map (lambda (c) (char->integer c)) step-1)] [step-3 (for/fold ([h 42]) ([b (in-list step-2)]) (let* ([body-1 (* b 3432918353)] [body-2 (modulo body-1 4294967296)] [body-3 (bitwise-ior (arithmetic-shift body-2 15) (arithmetic-shift body-2 -17))] [body-4 (modulo body-3 4294967296)] [body-5 (* body-4 461845907)] [body-6 (modulo body-5 4294967296)] [body-7 (bitwise-xor h body-6)] [body-8 (bitwise-ior (arithmetic-shift body-7 13) (arithmetic-shift body-7 -19))] [body-9 (modulo body-8 4294967296)] [body-10 (* body-9 5)] [body-11 (+ body-10 3864292196)] [body-12 (modulo body-11 4294967296)]) body-12))] [step-4 (length step-2)] [step-5 (bitwise-xor step-3 step-4)] [step-6 (arithmetic-shift step-5 -16)] [step-7 (bitwise-xor step-5 step-6)] [step-8 (* step-7 2246822507)] [step-9 (modulo step-8 4294967296)] [step-10 (arithmetic-shift step-9 -13)] [step-11 (bitwise-xor step-9 step-10)] [step-12 (* step-11 3266489909)] [step-13 (modulo step-12 4294967296)] [step-14 (arithmetic-shift step-13 -16)] [step-15 (bitwise-xor step-13 step-14)] [step-16 (modulo step-15 4294967296)] ) step-16)

  - name: sieve_of_eratosthenes
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "sieve-of-eratosthenes"
    description: "Sieve of Eratosthenes: find all primes up to n"
    racket_body: |
      (let* ( [step-1 (+ n 1)] [step-2 (make-vector step-1 #t)] [step-3 (vector-set! step-2 0 #f)] [step-4 (vector-set! step-2 1 #f)] [step-5 (sqrt n)] [step-6 (exact-floor step-5)] [step-7 (+ step-6 1)] [step-8 (for ([i (in-range 2 step-7)]) (when (vector-ref step-2 i) (let* ([body-1 (* i i)] [body-2 (for ([j (in-range body-1 (+ n 1) i)]) (vector-set! step-2 j #f))]) body-2)))] [step-9 (range 2 (+ n 1))] [step-10 (for/fold ([primes (list)]) ([i (in-list step-9)]) (cond [(vector-ref step-2 i) (append primes (list i))] [else primes]))] ) step-10)

  - name: monte_carlo_pi
    inputs: ['Number']
    input_names: ['n']
    output: "Number"
    racket_symbol: "monte-carlo-pi"
    description: "Monte Carlo Pi estimation using fixed seed"
    racket_body: |
      (let* ( [step-1 (random-seed 42)] [step-2 (range 0 n)] [step-3 (for/sum ([_ (in-list step-2)]) (let* ([body-1 (random)] [body-2 (random)] [body-3 (* body-1 body-1)] [body-4 (* body-2 body-2)] [body-5 (+ body-3 body-4)] [body-6 (cond [(<= body-5 1.0) 1] [else 0])]) body-6))] [step-4 (* 4.0 step-3)] [step-5 (/ step-4 n)] [step-6 (* step-5 100)] [step-7 (round step-6)] [step-8 (/ step-7 100)] ) step-8)

  - name: insertion_sort
    inputs: ['List(Number)']
    input_names: ['lst']
    output: "Number"
    racket_symbol: "insertion-sort"
    description: "Insertion sort"
    racket_body: |
      (for/fold ([sorted (list)]) ([x (in-list lst)]) (let loop ([s sorted] [acc (list)]) (cond [(null? s) (append (reverse acc) (list x))] [(<= x (car s)) (append (reverse acc) (cons x s))] [else (loop (cdr s) (cons (car s) acc))])))

  - name: aho_corasick
    inputs: ['String']
    input_names: ['text']
    output: "Number"
    racket_symbol: "aho-corasick"
    description: "Aho-Corasick: multi-pattern search (simplified — count total matches)"
    racket_body: |
      (let* ( [step-1 (list "he" "she" "his" "hers")] [step-2 (for/sum ([pat (in-list step-1)]) (let* ([body-1 (string-length pat)] [body-2 (string-length text)] [body-3 (- body-2 body-1)] [body-4 (+ body-3 1)] [body-5 (range 0 body-4)] [body-6 (for/sum ([i (in-list body-5)]) (let* ([body-1 (+ i body-1)] [body-2 (cond [(string=? (substring text i body-1) pat) 1] [else 0])]) body-2))]) body-6))] ) step-2)

  - name: hamming_distance
    inputs: ['String', 'String']
    input_names: ['s1', 's2']
    output: "Number"
    racket_symbol: "hamming-distance"
    description: "Hamming distance: count positions where strings differ"
    racket_body: |
      (let* ( [step-1 (string-length s1)] [step-2 (range 0 step-1)] [step-3 (for/sum ([i (in-list step-2)]) (let* ([body-1 (string-ref s1 i)] [body-2 (string-ref s2 i)] [body-3 (cond [(char=? body-1 body-2) 0] [else 1])]) body-3))] ) step-3)

  - name: csv_column_sum
    inputs: ['String', 'Number']
    input_names: ['data', 'col']
    output: "Number"
    racket_symbol: "csv-column-sum"
    description: "CSV column sum: parse CSV rows and sum a numeric column"
    racket_body: |
      (let* ([rows (regexp-split (regexp-quote "\n") data)]) (for/sum ([row (in-list rows)]) (let* ([fields (string-split row ",")] [val (list-ref fields col)]) (string->number val))))

  - name: multi_substring_count
    inputs: ['String', 'String']
    input_names: ['data', 'sub']
    output: "Number"
    racket_symbol: "multi-substring-count"
    description: "Multi-string substring count: count total occurrences of a pattern across comma-separated strings"
    racket_body: |
      (let* ([parts (regexp-split (regexp-quote ",") data)]) (for/sum ([s (in-list parts)]) (let ([slen (string-length s)] [sublen (string-length sub)]) (if (= sublen 0) 0 (let loop ([i 0] [count 0]) (if (> (+ i sublen) slen) count (if (string=? (substring s i (+ i sublen)) sub) (loop (+ i sublen) (+ count 1)) (loop (+ i 1) count))))))))

  - name: word_frequency
    inputs: ['String', 'String']
    input_names: ['text', 'target']
    output: "Number"
    racket_symbol: "word-frequency"
    description: "Word frequency: count occurrences of a target word in text"
    racket_body: |
      (let* ([words (regexp-split (regexp-quote " ") text)]) (for/sum ([w (in-list words)]) (if (equal? w target) 1 0)))
