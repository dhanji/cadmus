# Racket Operations Pack
# ======================
# Domain-specific typed operations for Racket language programming.
# Loaded at runtime by the ops pack loader — no Rust recompilation needed.
#
# Design:
#   - Only `add` (+) is listed here with a full metasignature
#   - subtract, multiply, divide are NOT listed — the inference engine
#     discovers them from the fact pack (phase 0) and derives their
#     signatures via symmetry/type-symmetry relations from add's metasig
#   - List/set and composable ops follow the same TypeExpr patterns as
#     fs.ops.yaml (Seq, Entry, etc.)
#   - Printing ops use a simple Value → Unit pattern
#   - Every op carries a `racket_symbol` — the actual Racket identifier
#     used in s-expressions. The executor reads this at codegen time
#     instead of hardcoding op→symbol mappings.
#
# Type vocabulary:
#   Primitives: Number, Boolean, String, Symbol, Char, Void, Any
#   Constructors: List(a), Pair(a, b), Set(a), Seq(a), Option(a)

name: racket
description: "Racket language operations: arithmetic, lists, sets, I/O, and higher-order combinators"

ops:

  # =========================================================================
  # 1. Arithmetic
  # =========================================================================
  # Only + is fully defined. -, *, / are stubs — the reasoner infers their
  # full signatures from the symmetric_pair relations in racket.facts.yaml.

  - name: add
    racket_symbol: "+"
    inputs: ["Number", "Number"]
    output: "Number"
    properties:
      commutative: true
      associative: true
      identity: "0"
    description: "(+ x y) — add two numbers"
    meta:
      params:
        - { name: x, type: Number }
        - { name: y, type: Number, variadic: true }
      return_type: Number
      invariants:
        - "y>0 => x+y>x"
      category: arithmetic
      effects: none

  # subtract, multiply, divide are NOT listed here — they are discovered
  # from the fact pack by the inference engine (phase 0: discovery).

  - name: modulo
    racket_symbol: "modulo"
    inputs: ["Number", "Number"]
    output: "Number"
    description: "(modulo x y) — remainder of x divided by y"

  - name: expt
    racket_symbol: "expt"
    inputs: ["Number", "Number"]
    output: "Number"
    description: "(expt base exp) — raise base to exponent"

  - name: abs
    racket_symbol: "abs"
    inputs: ["Number"]
    output: "Number"
    properties:
      idempotent: true
    description: "(abs x) — absolute value"

  - name: min
    racket_symbol: "min"
    inputs: ["Number", "Number"]
    output: "Number"
    properties:
      commutative: true
      associative: true
      idempotent: true
    description: "(min x y) — smaller of two numbers"

  - name: max
    racket_symbol: "max"
    inputs: ["Number", "Number"]
    output: "Number"
    properties:
      commutative: true
      associative: true
      idempotent: true
    description: "(max x y) — larger of two numbers"

  # =========================================================================
  # 2. List Operations
  # =========================================================================

  - name: cons
    racket_symbol: "cons"
    type_params: [a]
    inputs: ["a", "List(a)"]
    output: "List(a)"
    description: "(cons x lst) — prepend element to list"
    meta:
      type_params: [a]
      params:
        - { name: x, type: "a" }
        - { name: lst, type: "List(a)" }
      return_type: "List(a)"
      invariants: []
      category: list
      effects: none

  - name: car
    racket_symbol: "car"
    type_params: [a]
    inputs: ["List(a)"]
    output: "a"
    description: "(car lst) — first element of list"

  - name: cdr
    racket_symbol: "cdr"
    type_params: [a]
    inputs: ["List(a)"]
    output: "List(a)"
    description: "(cdr lst) — rest of list after first element"
    meta:
      type_params: [a]
      params:
        - { name: lst, type: "List(a)" }
      return_type: "List(a)"
      invariants: []
      category: list
      effects: none

  - name: list_new
    racket_symbol: "list"
    type_params: [a]
    inputs: ["a"]
    output: "List(a)"
    properties:
      variadic: true
    description: "(list x ...) — create a new list from elements"

  - name: append
    racket_symbol: "append"
    type_params: [a]
    inputs: ["List(a)", "List(a)"]
    output: "List(a)"
    properties:
      associative: true
      identity: "'()"
    description: "(append lst1 lst2) — concatenate two lists"

  - name: length
    racket_symbol: "length"
    type_params: [a]
    inputs: ["List(a)"]
    output: "Number"
    properties:
      idempotent: true
    description: "(length lst) — number of elements"

  # list_reverse is NOT listed here — discovered from the fact pack
  # and inferred via type-symmetric from cdr (class: list_to_list).

  - name: list_ref
    racket_symbol: "list-ref"
    type_params: [a]
    inputs: ["List(a)", "Number"]
    output: "a"
    description: "(list-ref lst idx) — element at index"

  - name: member
    racket_symbol: "member"
    type_params: [a]
    inputs: ["a", "List(a)"]
    output: "Option(List(a))"
    description: "(member v lst) — sublist starting at v, or #f"

  # remove is NOT listed here — discovered from the fact pack
  # and inferred via type-symmetric from cons (class: list_elem_to_list).

  - name: sort_list
    racket_symbol: "sort"
    type_params: [a]
    inputs: ["List(a)"]
    output: "List(a)"
    properties:
      idempotent: true
    description: "(sort lst <) — sort list by comparator"

  - name: flatten
    racket_symbol: "flatten"
    type_params: [a]
    inputs: ["List(List(a))"]
    output: "List(a)"
    description: "(flatten lst) — flatten nested lists"

  # =========================================================================
  # 3. Set Operations
  # =========================================================================

  - name: set_new
    racket_symbol: "list->set"
    type_params: [a]
    inputs: ["List(a)"]
    output: "Set(a)"
    description: "(list->set lst) — create set from list"

  - name: set_add
    racket_symbol: "set-add"
    type_params: [a]
    inputs: ["Set(a)", "a"]
    output: "Set(a)"
    description: "(set-add s v) — add element to set"

  - name: set_remove
    racket_symbol: "set-remove"
    type_params: [a]
    inputs: ["Set(a)", "a"]
    output: "Set(a)"
    description: "(set-remove s v) — remove element from set"

  - name: set_member
    racket_symbol: "set-member?"
    type_params: [a]
    inputs: ["Set(a)", "a"]
    output: "Boolean"
    properties:
      idempotent: true
    description: "(set-member? s v) — test membership"

  - name: set_union
    racket_symbol: "set-union"
    type_params: [a]
    inputs: ["Set(a)", "Set(a)"]
    output: "Set(a)"
    properties:
      commutative: true
      associative: true
      idempotent: true
    description: "(set-union s1 s2) — union of two sets"

  - name: set_intersect
    racket_symbol: "set-intersect"
    type_params: [a]
    inputs: ["Set(a)", "Set(a)"]
    output: "Set(a)"
    properties:
      commutative: true
      associative: true
      idempotent: true
    description: "(set-intersect s1 s2) — intersection of two sets"

  - name: set_subtract
    racket_symbol: "set-subtract"
    type_params: [a]
    inputs: ["Set(a)", "Set(a)"]
    output: "Set(a)"
    description: "(set-subtract s1 s2) — elements in s1 not in s2"

  - name: set_count
    racket_symbol: "set-count"
    type_params: [a]
    inputs: ["Set(a)"]
    output: "Number"
    properties:
      idempotent: true
    description: "(set-count s) — number of elements in set"

  - name: set_to_list
    racket_symbol: "set->list"
    type_params: [a]
    inputs: ["Set(a)"]
    output: "List(a)"
    description: "(set->list s) — convert set to list"

  # =========================================================================
  # 4. Printing and Stdio (display form)
  # =========================================================================

  - name: display
    racket_symbol: "display"
    inputs: ["Any"]
    output: "Void"
    description: "(display v) — print value without newline"

  - name: displayln
    racket_symbol: "displayln"
    inputs: ["Any"]
    output: "Void"
    description: "(displayln v) — print value with newline"

  - name: newline
    racket_symbol: "newline"
    output: "Void"
    description: "(newline) — print a newline"

  - name: read_line
    racket_symbol: "read-line"
    output: "String"
    description: "(read-line) — read a line from stdin"

  - name: format_string
    racket_symbol: "format"
    inputs: ["String", "Any"]
    output: "String"
    description: "(format fmt v ...) — format string with values"

  - name: printf
    racket_symbol: "printf"
    inputs: ["String", "Any"]
    output: "Void"
    description: "(printf fmt v ...) — formatted print"

  # =========================================================================
  # 4b. File I/O
  # =========================================================================

  - name: file_read
    racket_symbol: "file->string"
    inputs: ["String"]
    output: "String"
    description: "(file->string path) — read entire file as string"

  - name: file_read_lines
    racket_symbol: "file->lines"
    inputs: ["String"]
    output: "List(String)"
    description: "(file->lines path) — read file as list of lines"

  - name: file_write
    racket_symbol: "display-to-file"
    inputs: ["String", "String"]
    output: "Void"
    description: "(display-to-file content path) — write string to file"

  - name: file_exists
    racket_symbol: "file-exists?"
    inputs: ["String"]
    output: "Boolean"
    description: "(file-exists? path) — check if file exists"

  - name: file_delete
    racket_symbol: "delete-file"
    inputs: ["String"]
    output: "Void"
    description: "(delete-file path) — delete a file"

  # =========================================================================
  # 5. Higher-Order / Composable Operations
  # =========================================================================

  - name: racket_map
    racket_symbol: "map"
    type_params: [a, b]
    inputs: ["List(a)"]
    output: "List(b)"
    description: "(map f lst) — apply function to each element"

  - name: racket_filter
    racket_symbol: "filter"
    type_params: [a]
    inputs: ["List(a)"]
    output: "List(a)"
    properties:
      idempotent: true
    description: "(filter pred lst) — keep elements matching predicate"

  - name: racket_foldl
    racket_symbol: "foldl"
    type_params: [a, b]
    inputs: ["b", "List(a)"]
    output: "b"
    description: "(foldl f init lst) — left fold over list"

  - name: racket_foldr
    racket_symbol: "foldr"
    type_params: [a, b]
    inputs: ["b", "List(a)"]
    output: "b"
    description: "(foldr f init lst) — right fold over list"

  - name: racket_for_each
    racket_symbol: "for-each"
    type_params: [a]
    inputs: ["List(a)"]
    output: "Void"
    description: "(for-each f lst) — apply side-effecting function to each element"

  - name: racket_apply
    racket_symbol: "apply"
    type_params: [a, b]
    inputs: ["List(a)"]
    output: "b"
    description: "(apply f lst) — apply function to list as arguments"

  - name: andmap
    racket_symbol: "andmap"
    type_params: [a]
    inputs: ["List(a)"]
    output: "Boolean"
    description: "(andmap pred lst) — true if predicate holds for all elements"

  - name: ormap
    racket_symbol: "ormap"
    type_params: [a]
    inputs: ["List(a)"]
    output: "Boolean"
    description: "(ormap pred lst) — true if predicate holds for any element"

  # =========================================================================
  # 6. Boolean and Comparison
  # =========================================================================
  # 5b. Iteration Forms (for/*, named-let)
  # =========================================================================

  - name: for_fold
    racket_symbol: "for/fold"
    type_params: [a, b]
    inputs: ["b"]
    output: "b"
    description: "(for/fold ([acc init]) ([x seq]) body) — general accumulator loop"

  - name: for_list
    racket_symbol: "for/list"
    type_params: [a, b]
    inputs: ["a"]
    output: "List(b)"
    description: "(for/list ([x seq]) body) — build list from iteration"

  - name: for_each
    racket_symbol: "for-each"
    type_params: [a]
    inputs: ["a"]
    output: "Void"
    description: "(for-each (lambda (x) body) seq) — iterate for side effects"

  - name: cond
    racket_symbol: "cond"
    inputs: []
    output: "Any"
    description: "(cond [test then] ... [else val]) — multi-branch conditional"

  - name: map
    racket_symbol: "map"
    type_params: [a, b]
    inputs: ["List(a)"]
    output: "List(b)"
    description: "(map (lambda (x) body) lst) — transform each element"

  - name: for_sum
    racket_symbol: "for/sum"
    type_params: [a]
    inputs: ["a"]
    output: "Number"
    description: "(for/sum ([x seq]) body) — sum values from iteration"

  - name: for_product
    racket_symbol: "for/product"
    type_params: [a]
    inputs: ["a"]
    output: "Number"
    description: "(for/product ([x seq]) body) — multiply values from iteration"

  - name: for_and
    racket_symbol: "for/and"
    type_params: [a]
    inputs: ["a"]
    output: "Boolean"
    description: "(for/and ([x seq]) body) — true if body is true for all elements"

  - name: for_or
    racket_symbol: "for/or"
    type_params: [a]
    inputs: ["a"]
    output: "Boolean"
    description: "(for/or ([x seq]) body) — true if body is true for any element"

  - name: iterate
    racket_symbol: "let"
    type_params: [a]
    inputs: ["a"]
    output: "a"
    description: "(let name ([var init] ...) body) — named-let loop for complex iteration"

  # =========================================================================
  # 5c. Control Flow and Binding
  # =========================================================================

  - name: conditional
    racket_symbol: "cond"
    type_params: [a]
    inputs: ["a"]
    output: "a"
    description: "(cond [test expr] ... [else expr]) — multi-branch conditional"

  - name: if_then
    racket_symbol: "if"
    type_params: [a]
    inputs: ["Boolean"]
    output: "a"
    description: "(if test then-expr else-expr) — two-branch conditional"

  - name: let_bind
    racket_symbol: "let*"
    type_params: [a]
    inputs: ["a"]
    output: "a"
    description: "(let* ([var expr] ...) body) — sequential binding"

  - name: begin
    racket_symbol: "begin"
    type_params: [a]
    inputs: ["a"]
    output: "a"
    description: "(begin expr ...) — sequence expressions, return last"

  - name: define
    racket_symbol: "define"
    type_params: [a]
    inputs: ["a"]
    output: "Void"
    description: "(define (name args) body) — define a function"

  # =========================================================================
  # 5d. Additional List Operations
  # =========================================================================

  - name: range
    racket_symbol: "range"
    inputs: ["Number"]
    output: "List(Number)"
    description: "(range n) or (range start end) — list of numbers"

  - name: build_list
    racket_symbol: "build-list"
    type_params: [a]
    inputs: ["Number"]
    output: "List(a)"
    description: "(build-list n f) — build list by applying f to 0..n-1"

  - name: list_take
    racket_symbol: "take"
    type_params: [a]
    inputs: ["List(a)", "Number"]
    output: "List(a)"
    description: "(take lst n) — first n elements"

  - name: list_drop
    racket_symbol: "drop"
    type_params: [a]
    inputs: ["List(a)", "Number"]
    output: "List(a)"
    description: "(drop lst n) — all but first n elements"

  # =========================================================================
  # 5e. Math Utilities
  # =========================================================================

  - name: quotient
    racket_symbol: "quotient"
    inputs: ["Number", "Number"]
    output: "Number"
    description: "(quotient a b) — integer division"

  - name: remainder
    racket_symbol: "remainder"
    inputs: ["Number", "Number"]
    output: "Number"
    description: "(remainder a b) — integer remainder"

  - name: sqrt
    racket_symbol: "sqrt"
    inputs: ["Number"]
    output: "Number"
    description: "(sqrt n) — square root"

  - name: exact_floor
    racket_symbol: "exact-floor"
    inputs: ["Number"]
    output: "Number"
    description: "(exact-floor n) — floor as exact integer"

  - name: exact_ceiling
    racket_symbol: "exact-ceiling"
    inputs: ["Number"]
    output: "Number"
    description: "(exact-ceiling n) — ceiling as exact integer"

  - name: round
    racket_symbol: "round"
    inputs: ["Number"]
    output: "Number"
    description: "(round n) — round to nearest integer"

  - name: exact_round
    racket_symbol: "exact-round"
    inputs: ["Number"]
    output: "Number"
    description: "(exact-round n) — round to nearest exact integer"

  - name: gcd
    racket_symbol: "gcd"
    inputs: ["Number", "Number"]
    output: "Number"
    description: "(gcd a b) — greatest common divisor"

  - name: lcm
    racket_symbol: "lcm"
    inputs: ["Number", "Number"]
    output: "Number"
    description: "(lcm a b) — least common multiple"

  - name: random
    racket_symbol: "random"
    inputs: ["Number"]
    output: "Number"
    description: "(random n) — random integer in [0, n)"

  # =========================================================================

  - name: not
    racket_symbol: "not"
    inputs: ["Boolean"]
    output: "Boolean"
    description: "(not v) — logical negation"

  - name: equal
    racket_symbol: "equal?"
    inputs: ["Any", "Any"]
    output: "Boolean"
    properties:
      commutative: true
    description: "(equal? a b) — structural equality"

  - name: less_than
    racket_symbol: "<"
    inputs: ["Number", "Number"]
    output: "Boolean"
    description: "(< a b) — numeric less-than"
    meta:
      params:
        - { name: a, type: Number }
        - { name: b, type: Number }
      return_type: Boolean
      invariants: []
      category: comparison
      effects: none

  # greater_than is NOT listed here — discovered from the fact pack
  # and inferred via op-symmetric from less_than.
  # less_than_or_equal and greater_than_or_equal are also discovered
  # via type-symmetric from less_than (class: comparison_binop).

  # =========================================================================
  # 7. String Operations
  # =========================================================================

  - name: string_append
    racket_symbol: "string-append"
    inputs: ["String", "String"]
    output: "String"
    properties:
      associative: true
      identity: "\"\""
    description: "(string-append s1 s2) — concatenate strings"

  - name: string_length
    racket_symbol: "string-length"
    inputs: ["String"]
    output: "Number"
    properties:
      idempotent: true
    description: "(string-length s) — length of string"

  - name: number_to_string
    racket_symbol: "number->string"
    inputs: ["Number"]
    output: "String"
    description: "(number->string n) — convert number to string"

  - name: string_to_number
    racket_symbol: "string->number"
    inputs: ["String"]
    output: "Number"
    description: "(string->number s) — parse string as number"

  - name: string_upcase
    racket_symbol: "string-upcase"
    inputs: ["String"]
    output: "String"
    description: "(string-upcase s) — convert string to uppercase"
    meta:
      params:
        - { name: s, type: String }
      return_type: String
      invariants:
        - "idempotent: (string-upcase (string-upcase s)) = (string-upcase s)"
      category: string
      effects: none

  # string_downcase is NOT listed here — discovered from the fact pack
  # and inferred via type-symmetric from string_upcase (class: string_to_string).

  # =========================================================================
  # 8. Shell Ops — Racket wrappers around CLI tools
  # =========================================================================
  # Each anchor represents an output-format class. Non-anchor tools in the
  # same class (e.g., cat, head, tail in shell_text_lines) are discovered
  # from the fact pack via type-symmetric inference. Submodes (flag variants)
  # are discovered in Phase 4 from macos_cli.facts.yaml submode properties.
  #
  # All shell ops produce List(String) (lines of output) or String (raw).
  # The Racket executor generates wrapper forms using (system ...) calls.

  # --- shell_text_lines anchor: ls ---
  - name: shell_ls
    racket_symbol: "shell-ls"
    inputs: ["String"]
    output: "List(String)"
    description: "(shell-ls path) — list directory contents, one entry per line"
    meta:
      params:
        - { name: path, type: String }
      return_type: "List(String)"
      invariants: []
      category: shell
      effects: io

  # --- shell_exec anchor: mv (fire-and-forget ops) ---
  - name: shell_mv
    racket_symbol: "shell-mv"
    inputs: ["String", "String"]
    output: "String"
    description: "(shell-mv src dst) — move/rename files"
    meta:
      params:
        - { name: src, type: String }
        - { name: dst, type: String }
      return_type: String
      invariants: []
      category: shell
      effects: io

  # cp, rm, mkdir, ln, chmod, chown, tar, rsync, open, pbcopy, kill, pkill,
  # gzip, xz are NOT listed here — discovered via type-symmetric from mv
  # (class: shell_exec).

  # --- shell_archive anchors: unzip, zip, unrar, 7z ---
  - name: shell_unzip
    racket_symbol: "shell-unzip"
    inputs: ["String"]
    output: "List(String)"
    description: "(shell-unzip path) — extract ZIP archive, list extracted files"
    meta:
      params:
        - { name: path, type: String }
      return_type: "List(String)"
      invariants: []
      category: shell
      effects: io

  - name: shell_zip
    racket_symbol: "shell-zip"
    inputs: ["String", "String"]
    output: "String"
    description: "(shell-zip archive file) — add file to ZIP archive"
    meta:
      params:
        - { name: archive, type: String }
        - { name: file, type: String }
      return_type: String
      invariants: []
      category: shell
      effects: io

  - name: shell_unrar
    racket_symbol: "shell-unrar"
    inputs: ["String"]
    output: "List(String)"
    description: "(shell-unrar path) — extract RAR archive, list extracted files"
    meta:
      params:
        - { name: path, type: String }
      return_type: "List(String)"
      invariants: []
      category: shell
      effects: io

  - name: shell_7z
    racket_symbol: "shell-7z"
    inputs: ["String"]
    output: "List(String)"
    description: "(shell-7z path) — extract 7z archive, list extracted files"
    meta:
      params:
        - { name: path, type: String }
      return_type: "List(String)"
      invariants: []
      category: shell
      effects: io

  # --- shell_vcs anchor: git ---
  - name: shell_git
    racket_symbol: "shell-git"
    inputs: ["String"]
    output: "List(String)"
    description: "(shell-git args) — run git subcommand"
    meta:
      params:
        - { name: args, type: String }
      return_type: "List(String)"
      invariants: []
      category: shell
      effects: io

  # --- shell_structured anchor: jq ---
  - name: shell_jq
    racket_symbol: "shell-jq"
    inputs: ["String", "String"]
    output: "List(String)"
    description: "(shell-jq filter file) — process JSON with jq"
    meta:
      params:
        - { name: filter, type: String }
        - { name: file, type: String }
      return_type: "List(String)"
      invariants: []
      category: shell
      effects: io

  # yq is NOT listed here — discovered via type-symmetric from jq
  # (class: shell_structured).

  # --- shell_session anchor: tmux ---
  - name: shell_tmux
    racket_symbol: "shell-tmux"
    inputs: ["String"]
    output: "String"
    description: "(shell-tmux args) — run tmux subcommand"
    meta:
      params:
        - { name: args, type: String }
      return_type: String
      invariants: []
      category: shell
      effects: io

  # screen is NOT listed here — discovered via type-symmetric from tmux
  # (class: shell_session).

  # --- shell_network anchor: ssh ---
  - name: shell_ssh
    racket_symbol: "shell-ssh"
    inputs: ["String", "String"]
    output: "List(String)"
    description: "(shell-ssh host command) — execute command on remote host"
    meta:
      params:
        - { name: host, type: String }
        - { name: command, type: String }
      return_type: "List(String)"
      invariants: []
      category: shell
      effects: io

  # scp, nc are NOT listed here — discovered via type-symmetric from ssh
  # (class: shell_network).

  # cat, head, tail, sort are NOT listed here — discovered from the fact
  # pack via type-symmetric inference (class: shell_text_lines).

  # --- shell_tabular anchor: ps ---
  - name: shell_ps
    racket_symbol: "shell-ps"
    inputs: []
    output: "List(String)"
    description: "(shell-ps) — list running processes as lines"
    meta:
      params: []
      return_type: "List(String)"
      invariants: []
      category: shell
      effects: io

  # df is NOT listed here — discovered via type-symmetric (class: shell_tabular).

  # --- shell_tree anchor: find ---
  - name: shell_find
    racket_symbol: "shell-find"
    inputs: ["String"]
    output: "List(String)"
    description: "(shell-find path) — recursively walk directory tree, one path per line"
    meta:
      params:
        - { name: path, type: String }
      return_type: "List(String)"
      invariants: []
      category: shell
      effects: io

  # --- shell_filtered_lines anchor: grep ---
  - name: shell_grep
    racket_symbol: "shell-grep"
    inputs: ["String", "String"]
    output: "List(String)"
    description: "(shell-grep pattern path) — search for pattern in files, matching lines"
    meta:
      params:
        - { name: pattern, type: String }
        - { name: path, type: String }
      return_type: "List(String)"
      invariants: []
      category: shell
      effects: io

  # --- shell_single_value anchor: du ---
  - name: shell_du
    racket_symbol: "shell-du"
    inputs: ["String"]
    output: "String"
    description: "(shell-du path) — estimate file space usage"
    meta:
      params:
        - { name: path, type: String }
      return_type: String
      invariants: []
      category: shell
      effects: io

  # wc is NOT listed here — discovered via type-symmetric (class: shell_single_value).

  # --- shell_byte_stream anchor: curl ---
  - name: shell_curl
    racket_symbol: "shell-curl"
    inputs: ["String"]
    output: "String"
    description: "(shell-curl url) — download URL contents as string"
    meta:
      params:
        - { name: url, type: String }
      return_type: String
      invariants: []
      category: shell
      effects: io

  # =========================================================================
  # 9. Vector Operations
  # =========================================================================

  - name: make_vector
    racket_symbol: "make-vector"
    inputs: ["Number", "Any"]
    output: "Vector(Any)"
    description: "(make-vector size init) — create a vector of given size filled with init"

  - name: vector_ref
    racket_symbol: "vector-ref"
    type_params: [a]
    inputs: ["Vector(a)", "Number"]
    output: "a"
    description: "(vector-ref v i) — get element at index i"

  - name: vector_set
    racket_symbol: "vector-set!"
    type_params: [a]
    inputs: ["Vector(a)", "Number", "a"]
    output: "Void"
    description: "(vector-set! v i val) — set element at index i"

  - name: vector_new
    racket_symbol: "vector"
    inputs: []
    output: "Vector(Any)"
    description: "(vector e ...) — create a vector from elements"
    properties:
      variadic: true

  - name: vector_length
    racket_symbol: "vector-length"
    type_params: [a]
    inputs: ["Vector(a)"]
    output: "Number"
    description: "(vector-length v) — number of elements"

  - name: vector_to_list
    racket_symbol: "vector->list"
    type_params: [a]
    inputs: ["Vector(a)"]
    output: "List(a)"
    description: "(vector->list v) — convert vector to list"

  - name: list_to_vector
    racket_symbol: "list->vector"
    type_params: [a]
    inputs: ["List(a)"]
    output: "Vector(a)"
    description: "(list->vector lst) — convert list to vector"

  - name: build_vector
    racket_symbol: "build-vector"
    inputs: ["Number"]
    output: "Vector(Any)"
    description: "(build-vector n f) — create vector of size n using function f"

  # =========================================================================
  # 10. Character Operations
  # =========================================================================

  - name: char_to_integer
    racket_symbol: "char->integer"
    inputs: ["Char"]
    output: "Number"
    description: "(char->integer c) — character to Unicode code point"

  - name: integer_to_char
    racket_symbol: "integer->char"
    inputs: ["Number"]
    output: "Char"
    description: "(integer->char n) — Unicode code point to character"

  - name: char_alphabetic
    racket_symbol: "char-alphabetic?"
    inputs: ["Char"]
    output: "Boolean"
    description: "(char-alphabetic? c) — is character a letter?"

  - name: char_upper_case
    racket_symbol: "char-upper-case?"
    inputs: ["Char"]
    output: "Boolean"
    description: "(char-upper-case? c) — is character uppercase?"

  - name: char_equal
    racket_symbol: "char=?"
    inputs: ["Char", "Char"]
    output: "Boolean"
    description: "(char=? a b) — are characters equal?"

  # =========================================================================
  # 11. String Operations (extended)
  # =========================================================================

  - name: string_to_list
    racket_symbol: "string->list"
    inputs: ["String"]
    output: "List(Char)"
    description: "(string->list s) — convert string to list of characters"

  - name: list_to_string
    racket_symbol: "list->string"
    inputs: ["List(Char)"]
    output: "String"
    description: "(list->string lst) — convert list of characters to string"

  - name: string_ref
    racket_symbol: "string-ref"
    inputs: ["String", "Number"]
    output: "Char"
    description: "(string-ref s i) — get character at index i"

  - name: substring_op
    racket_symbol: "substring"
    inputs: ["String", "Number", "Number"]
    output: "String"
    description: "(substring s start end) — extract substring"

  - name: string_equal
    racket_symbol: "string=?"
    inputs: ["String", "String"]
    output: "Boolean"
    description: "(string=? a b) — are strings equal?"

  - name: number_to_string_conv
    racket_symbol: "number->string"
    inputs: ["Number"]
    output: "String"
    description: "(number->string n) — convert number to string"

  # =========================================================================
  # 12. Bitwise Operations
  # =========================================================================

  - name: bitwise_and
    racket_symbol: "bitwise-and"
    inputs: ["Number", "Number"]
    output: "Number"
    description: "(bitwise-and a b) — bitwise AND"

  - name: bitwise_or
    racket_symbol: "bitwise-ior"
    inputs: ["Number", "Number"]
    output: "Number"
    description: "(bitwise-ior a b) — bitwise OR"

  - name: bitwise_xor
    racket_symbol: "bitwise-xor"
    inputs: ["Number", "Number"]
    output: "Number"
    description: "(bitwise-xor a b) — bitwise XOR"

  - name: arithmetic_shift
    racket_symbol: "arithmetic-shift"
    inputs: ["Number", "Number"]
    output: "Number"
    description: "(arithmetic-shift n m) — shift n by m bits (positive=left, negative=right)"

  # =========================================================================
  # 13. Boolean / Predicate Operations
  # =========================================================================

  - name: odd_check
    racket_symbol: "odd?"
    inputs: ["Number"]
    output: "Boolean"
    description: "(odd? n) — is n odd?"

  - name: even_check
    racket_symbol: "even?"
    inputs: ["Number"]
    output: "Boolean"
    description: "(even? n) — is n even?"

  - name: null_check
    racket_symbol: "null?"
    type_params: [a]
    inputs: ["List(a)"]
    output: "Boolean"
    description: "(null? lst) — is list empty?"

  - name: and_logic
    racket_symbol: "and"
    inputs: ["Boolean", "Boolean"]
    output: "Boolean"
    description: "(and a b) — logical AND"

  - name: or_logic
    racket_symbol: "or"
    inputs: ["Boolean", "Boolean"]
    output: "Boolean"
    description: "(or a b) — logical OR"

  # =========================================================================
  # 14. List Operations (extended)
  # =========================================================================

  - name: reverse_list
    racket_symbol: "reverse"
    type_params: [a]
    inputs: ["List(a)"]
    output: "List(a)"
    description: "(reverse lst) — reverse a list"

  - name: first_elem
    racket_symbol: "first"
    type_params: [a]
    inputs: ["List(a)"]
    output: "a"
    description: "(first lst) — first element"

  - name: second_elem
    racket_symbol: "second"
    type_params: [a]
    inputs: ["List(a)"]
    output: "a"
    description: "(second lst) — second element"

  - name: third_elem
    racket_symbol: "third"
    type_params: [a]
    inputs: ["List(a)"]
    output: "a"
    description: "(third lst) — third element"

  - name: remove_duplicates
    racket_symbol: "remove-duplicates"
    type_params: [a]
    inputs: ["List(a)"]
    output: "List(a)"
    description: "(remove-duplicates lst) — remove duplicate elements"

  - name: apply_max
    racket_symbol: "apply-max"
    inputs: ["List(Number)"]
    output: "Number"
    description: "(apply max lst) — maximum element of list"

  - name: apply_min
    racket_symbol: "apply-min"
    inputs: ["List(Number)"]
    output: "Number"
    description: "(apply min lst) — minimum element of list"

  # =========================================================================
  # 15. Mutable State Operations
  # =========================================================================

  - name: box_new
    racket_symbol: "box"
    inputs: ["Any"]
    output: "Box(Any)"
    description: "(box v) — create a mutable box"

  - name: unbox_val
    racket_symbol: "unbox"
    inputs: ["Box(Any)"]
    output: "Any"
    description: "(unbox b) — read the value in a box"

  - name: set_box
    racket_symbol: "set-box!"
    inputs: ["Box(Any)", "Any"]
    output: "Void"
    description: "(set-box! b v) — set the value in a box"

  - name: set_bang
    racket_symbol: "set!"
    inputs: ["Any", "Any"]
    output: "Void"
    description: "(set! var val) — mutate a variable"

  # =========================================================================
  # 16. Control Flow Operations
  # =========================================================================

  - name: when_do
    racket_symbol: "when"
    inputs: ["Boolean", "Any"]
    output: "Void"
    description: "(when test body) — execute body when test is true"

  - name: make_prng
    racket_symbol: "make-pseudo-random-generator"
    inputs: []
    output: "Any"
    description: "(make-pseudo-random-generator) — create a PRNG"

  - name: random_seed
    racket_symbol: "random-seed"
    inputs: ["Number"]
    output: "Void"
    description: "(random-seed n) — seed the random number generator"

  # =========================================================================
  # 17. Plan DSL Control Flow Ops
  # =========================================================================
  # These ops are used by the plan DSL for structured sub-step pipelines.
  # They compile to Racket control flow forms (for/fold, map, for-each, etc.)

  - name: fold
    racket_symbol: "for/fold"
    type_params: [a, b]
    inputs: ["b", "List(a)"]
    output: "b"
    description: "fold — accumulate over a sequence with sub-step body"

  - name: for_range
    racket_symbol: "for"
    inputs: ["Number", "Number"]
    output: "Void"
    description: "for_range — iterate over integer range with sub-step body"

  - name: for_range_down
    racket_symbol: "for"
    inputs: ["Number", "Number"]
    output: "Void"
    description: "for_range_down — iterate over integer range in reverse"

  - name: for_list_star
    racket_symbol: "for*/list"
    inputs: []
    output: "List(Any)"
    description: "for*/list — nested iteration producing a list"

  - name: take
    racket_symbol: "take"
    inputs: ["List(a)", "Number"]
    output: "List(a)"
    description: "(take lst n) — first n elements of list"

  - name: drop
    racket_symbol: "drop"
    inputs: ["List(a)", "Number"]
    output: "List(a)"
    description: "(drop lst n) — all but first n elements of list"

  - name: for_star
    racket_symbol: "for*"
    inputs: []
    output: "Void"
    description: "for* — nested iteration for side effects"
