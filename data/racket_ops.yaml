# Racket Operations Pack
# ======================
# Domain-specific typed operations for Racket language programming.
# Loaded at runtime by the ops pack loader — no Rust recompilation needed.
#
# Design:
#   - Only `add` (+) is listed here with a full metasignature
#   - subtract, multiply, divide are NOT listed — the inference engine
#     discovers them from the fact pack (phase 0) and derives their
#     signatures via symmetry/type-symmetry relations from add's metasig
#   - List/set and composable ops follow the same TypeExpr patterns as
#     fs_ops.yaml (Seq, Entry, etc.)
#   - Printing ops use a simple Value → Unit pattern
#   - Every op carries a `racket_symbol` — the actual Racket identifier
#     used in s-expressions. The executor reads this at codegen time
#     instead of hardcoding op→symbol mappings.
#
# Type vocabulary:
#   Primitives: Number, Boolean, String, Symbol, Char, Void, Any
#   Constructors: List(a), Pair(a, b), Set(a), Seq(a), Option(a)

name: racket
description: "Racket language operations: arithmetic, lists, sets, I/O, and higher-order combinators"

ops:

  # =========================================================================
  # 1. Arithmetic
  # =========================================================================
  # Only + is fully defined. -, *, / are stubs — the reasoner infers their
  # full signatures from the symmetric_pair relations in racket_facts.yaml.

  - name: add
    racket_symbol: "+"
    inputs: ["Number", "Number"]
    output: "Number"
    properties:
      commutative: true
      associative: true
      identity: "0"
    description: "(+ x y) — add two numbers"
    meta:
      params:
        - { name: x, type: Number }
        - { name: y, type: Number, variadic: true }
      return_type: Number
      invariants:
        - "y>0 => x+y>x"
      category: arithmetic
      effects: none

  # subtract, multiply, divide are NOT listed here — they are discovered
  # from the fact pack by the inference engine (phase 0: discovery).

  - name: modulo
    racket_symbol: "modulo"
    inputs: ["Number", "Number"]
    output: "Number"
    description: "(modulo x y) — remainder of x divided by y"

  - name: expt
    racket_symbol: "expt"
    inputs: ["Number", "Number"]
    output: "Number"
    description: "(expt base exp) — raise base to exponent"

  - name: abs
    racket_symbol: "abs"
    inputs: ["Number"]
    output: "Number"
    properties:
      idempotent: true
    description: "(abs x) — absolute value"

  - name: min
    racket_symbol: "min"
    inputs: ["Number", "Number"]
    output: "Number"
    properties:
      commutative: true
      associative: true
      idempotent: true
    description: "(min x y) — smaller of two numbers"

  - name: max
    racket_symbol: "max"
    inputs: ["Number", "Number"]
    output: "Number"
    properties:
      commutative: true
      associative: true
      idempotent: true
    description: "(max x y) — larger of two numbers"

  # =========================================================================
  # 2. List Operations
  # =========================================================================

  - name: cons
    racket_symbol: "cons"
    type_params: [a]
    inputs: ["a", "List(a)"]
    output: "List(a)"
    description: "(cons x lst) — prepend element to list"
    meta:
      type_params: [a]
      params:
        - { name: x, type: "a" }
        - { name: lst, type: "List(a)" }
      return_type: "List(a)"
      invariants: []
      category: list
      effects: none

  - name: car
    racket_symbol: "car"
    type_params: [a]
    inputs: ["List(a)"]
    output: "a"
    description: "(car lst) — first element of list"

  - name: cdr
    racket_symbol: "cdr"
    type_params: [a]
    inputs: ["List(a)"]
    output: "List(a)"
    description: "(cdr lst) — rest of list after first element"
    meta:
      type_params: [a]
      params:
        - { name: lst, type: "List(a)" }
      return_type: "List(a)"
      invariants: []
      category: list
      effects: none

  - name: list_new
    racket_symbol: "list"
    type_params: [a]
    inputs: ["a"]
    output: "List(a)"
    description: "(list x ...) — create a new list from elements"

  - name: append
    racket_symbol: "append"
    type_params: [a]
    inputs: ["List(a)", "List(a)"]
    output: "List(a)"
    properties:
      associative: true
      identity: "'()"
    description: "(append lst1 lst2) — concatenate two lists"

  - name: length
    racket_symbol: "length"
    type_params: [a]
    inputs: ["List(a)"]
    output: "Number"
    properties:
      idempotent: true
    description: "(length lst) — number of elements"

  # list_reverse is NOT listed here — discovered from the fact pack
  # and inferred via type-symmetric from cdr (class: list_to_list).

  - name: list_ref
    racket_symbol: "list-ref"
    type_params: [a]
    inputs: ["List(a)", "Number"]
    output: "a"
    description: "(list-ref lst idx) — element at index"

  - name: member
    racket_symbol: "member"
    type_params: [a]
    inputs: ["a", "List(a)"]
    output: "Option(List(a))"
    description: "(member v lst) — sublist starting at v, or #f"

  # remove is NOT listed here — discovered from the fact pack
  # and inferred via type-symmetric from cons (class: list_elem_to_list).

  - name: sort_list
    racket_symbol: "sort"
    type_params: [a]
    inputs: ["List(a)"]
    output: "List(a)"
    properties:
      idempotent: true
    description: "(sort lst <) — sort list by comparator"

  - name: flatten
    racket_symbol: "flatten"
    type_params: [a]
    inputs: ["List(List(a))"]
    output: "List(a)"
    description: "(flatten lst) — flatten nested lists"

  # =========================================================================
  # 3. Set Operations
  # =========================================================================

  - name: set_new
    racket_symbol: "list->set"
    type_params: [a]
    inputs: ["List(a)"]
    output: "Set(a)"
    description: "(list->set lst) — create set from list"

  - name: set_add
    racket_symbol: "set-add"
    type_params: [a]
    inputs: ["Set(a)", "a"]
    output: "Set(a)"
    description: "(set-add s v) — add element to set"

  - name: set_remove
    racket_symbol: "set-remove"
    type_params: [a]
    inputs: ["Set(a)", "a"]
    output: "Set(a)"
    description: "(set-remove s v) — remove element from set"

  - name: set_member
    racket_symbol: "set-member?"
    type_params: [a]
    inputs: ["Set(a)", "a"]
    output: "Boolean"
    properties:
      idempotent: true
    description: "(set-member? s v) — test membership"

  - name: set_union
    racket_symbol: "set-union"
    type_params: [a]
    inputs: ["Set(a)", "Set(a)"]
    output: "Set(a)"
    properties:
      commutative: true
      associative: true
      idempotent: true
    description: "(set-union s1 s2) — union of two sets"

  - name: set_intersect
    racket_symbol: "set-intersect"
    type_params: [a]
    inputs: ["Set(a)", "Set(a)"]
    output: "Set(a)"
    properties:
      commutative: true
      associative: true
      idempotent: true
    description: "(set-intersect s1 s2) — intersection of two sets"

  - name: set_subtract
    racket_symbol: "set-subtract"
    type_params: [a]
    inputs: ["Set(a)", "Set(a)"]
    output: "Set(a)"
    description: "(set-subtract s1 s2) — elements in s1 not in s2"

  - name: set_count
    racket_symbol: "set-count"
    type_params: [a]
    inputs: ["Set(a)"]
    output: "Number"
    properties:
      idempotent: true
    description: "(set-count s) — number of elements in set"

  - name: set_to_list
    racket_symbol: "set->list"
    type_params: [a]
    inputs: ["Set(a)"]
    output: "List(a)"
    description: "(set->list s) — convert set to list"

  # =========================================================================
  # 4. Printing and Stdio (display form)
  # =========================================================================

  - name: display
    racket_symbol: "display"
    inputs: ["Any"]
    output: "Void"
    description: "(display v) — print value without newline"

  - name: displayln
    racket_symbol: "displayln"
    inputs: ["Any"]
    output: "Void"
    description: "(displayln v) — print value with newline"

  - name: newline
    racket_symbol: "newline"
    output: "Void"
    description: "(newline) — print a newline"

  - name: read_line
    racket_symbol: "read-line"
    output: "String"
    description: "(read-line) — read a line from stdin"

  - name: format_string
    racket_symbol: "format"
    inputs: ["String", "Any"]
    output: "String"
    description: "(format fmt v ...) — format string with values"

  - name: printf
    racket_symbol: "printf"
    inputs: ["String", "Any"]
    output: "Void"
    description: "(printf fmt v ...) — formatted print"

  # =========================================================================
  # 5. Higher-Order / Composable Operations
  # =========================================================================

  - name: racket_map
    racket_symbol: "map"
    type_params: [a, b]
    inputs: ["List(a)"]
    output: "List(b)"
    description: "(map f lst) — apply function to each element"

  - name: racket_filter
    racket_symbol: "filter"
    type_params: [a]
    inputs: ["List(a)"]
    output: "List(a)"
    properties:
      idempotent: true
    description: "(filter pred lst) — keep elements matching predicate"

  - name: racket_foldl
    racket_symbol: "foldl"
    type_params: [a, b]
    inputs: ["b", "List(a)"]
    output: "b"
    description: "(foldl f init lst) — left fold over list"

  - name: racket_foldr
    racket_symbol: "foldr"
    type_params: [a, b]
    inputs: ["b", "List(a)"]
    output: "b"
    description: "(foldr f init lst) — right fold over list"

  - name: racket_for_each
    racket_symbol: "for-each"
    type_params: [a]
    inputs: ["List(a)"]
    output: "Void"
    description: "(for-each f lst) — apply side-effecting function to each element"

  - name: racket_apply
    racket_symbol: "apply"
    type_params: [a, b]
    inputs: ["List(a)"]
    output: "b"
    description: "(apply f lst) — apply function to list as arguments"

  - name: andmap
    racket_symbol: "andmap"
    type_params: [a]
    inputs: ["List(a)"]
    output: "Boolean"
    description: "(andmap pred lst) — true if predicate holds for all elements"

  - name: ormap
    racket_symbol: "ormap"
    type_params: [a]
    inputs: ["List(a)"]
    output: "Boolean"
    description: "(ormap pred lst) — true if predicate holds for any element"

  # =========================================================================
  # 6. Boolean and Comparison
  # =========================================================================

  - name: not
    racket_symbol: "not"
    inputs: ["Boolean"]
    output: "Boolean"
    description: "(not v) — logical negation"

  - name: equal
    racket_symbol: "equal?"
    inputs: ["Any", "Any"]
    output: "Boolean"
    properties:
      commutative: true
    description: "(equal? a b) — structural equality"

  - name: less_than
    racket_symbol: "<"
    inputs: ["Number", "Number"]
    output: "Boolean"
    description: "(< a b) — numeric less-than"
    meta:
      params:
        - { name: a, type: Number }
        - { name: b, type: Number }
      return_type: Boolean
      invariants: []
      category: comparison
      effects: none

  # greater_than is NOT listed here — discovered from the fact pack
  # and inferred via op-symmetric from less_than.
  # less_than_or_equal and greater_than_or_equal are also discovered
  # via type-symmetric from less_than (class: comparison_binop).

  # =========================================================================
  # 7. String Operations
  # =========================================================================

  - name: string_append
    racket_symbol: "string-append"
    inputs: ["String", "String"]
    output: "String"
    properties:
      associative: true
      identity: "\"\""
    description: "(string-append s1 s2) — concatenate strings"

  - name: string_length
    racket_symbol: "string-length"
    inputs: ["String"]
    output: "Number"
    properties:
      idempotent: true
    description: "(string-length s) — length of string"

  - name: number_to_string
    racket_symbol: "number->string"
    inputs: ["Number"]
    output: "String"
    description: "(number->string n) — convert number to string"

  - name: string_to_number
    racket_symbol: "string->number"
    inputs: ["String"]
    output: "Number"
    description: "(string->number s) — parse string as number"

  - name: string_upcase
    racket_symbol: "string-upcase"
    inputs: ["String"]
    output: "String"
    description: "(string-upcase s) — convert string to uppercase"
    meta:
      params:
        - { name: s, type: String }
      return_type: String
      invariants:
        - "idempotent: (string-upcase (string-upcase s)) = (string-upcase s)"
      category: string
      effects: none

  # string_downcase is NOT listed here — discovered from the fact pack
  # and inferred via type-symmetric from string_upcase (class: string_to_string).
