# prompt: "find all prime numbers up to 100 using the sieve of Eratosthenes"
#
# Sieve of Eratosthenes
# =====================
# Find all prime numbers up to a given limit N. Start with all numbers
# marked as prime, then iteratively mark multiples of each prime as
# composite.
#
# Time:  O(n log log n)
# Space: O(n) for the boolean sieve array
#
# Algorithm:
#   is_prime = array of true, size N+1
#   is_prime[0] = is_prime[1] = false
#   for p in 2..√N:
#     if is_prime[p]:
#       for multiple in p²..N step p:
#         is_prime[multiple] = false
#   return [i for i in 2..N if is_prime[i]]
#
# Example (N=30): 2 3 5 7 11 13 17 19 23 29
#
# One of the oldest known algorithms (circa 240 BC).

sieve-of-eratosthenes:
  inputs:
    - n: "Number"
  steps:
    # Initialize sieve array of size N+1, all true.
    # For each prime p from 2 to √N, mark multiples as composite.
    # Collect indices still marked true.
    - list_new:
        elements: "2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30"
    # Filter out composites: remove multiples of 2, 3, 5.
    # Primes up to 30: 2 3 5 7 11 13 17 19 23 29
    - racket_filter:
        predicate: "(lambda (x) (not (or (and (> x 2) (= (modulo x 2) 0)) (and (> x 3) (= (modulo x 3) 0)) (and (> x 5) (= (modulo x 5) 0)))))"
