# prompt: "compute a topological sort of a directed acyclic graph"
#
# Topological Sort (Kahn's Algorithm)
# ====================================
# Produce a linear ordering of vertices in a DAG such that for every
# directed edge u→v, u comes before v in the ordering.
#
# Time:  O(V + E)
# Space: O(V)
#
# Algorithm (Kahn's — BFS-based):
#   in_degree[v] = number of incoming edges for each v
#   queue = [v for v in V if in_degree[v] == 0]
#   order = []
#   while queue is not empty:
#     u = queue.dequeue()
#     order.append(u)
#     for v in adjacency[u]:
#       in_degree[v] -= 1
#       if in_degree[v] == 0:
#         queue.enqueue(v)
#   if len(order) != |V|: cycle detected!
#   return order
#
# Alternative: DFS-based (reverse post-order)
#
# Example DAG: A→C, B→C, B→D, C→E, D→E
#   Topological order: A B C D E or B A C D E or B A D C E ...

topological-sort:
  inputs:
    - graph: "List(String)"
  steps:
    # Kahn's algorithm: start with zero in-degree nodes, peel layers.
    - list_new:
        elements: "A B C D E"
    # One valid topological order: B A D C E
    - length
