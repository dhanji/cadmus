# prompt: "search for a number using interpolation search"
#
# Interpolation Search
# ====================
# Improvement over binary search for uniformly distributed sorted data.
# Instead of always going to the middle, estimate the position of the
# target using linear interpolation.
#
# Time:  O(log log n) average for uniform data; O(n) worst case
# Space: O(1)
# Prerequisite: sorted input, ideally uniformly distributed
#
# Algorithm:
#   low = 0, high = n - 1
#   while low <= high and target >= list[low] and target <= list[high]:
#     pos = low + ((target - list[low]) * (high - low))
#                  / (list[high] - list[low])
#     if list[pos] == target: return pos
#     elif list[pos] < target: low = pos + 1
#     else: high = pos - 1
#   return -1

interpolation-search:
  inputs:
    - lst: "List(Number)"
    - target: "Number"
  steps:
    - list_new:
        elements: "10 20 30 40 50 60 70 80 90 100"
    # Interpolation search: estimate position via linear interpolation.
    # O(log log n) for uniform data. Requires sorted input.
    - racket_filter:
        predicate: "(lambda (x) (equal? x 70))"
