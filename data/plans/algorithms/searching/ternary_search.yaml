# prompt: "search for a number using ternary search"
#
# Ternary Search
# ==============
# Divide the sorted array into three parts (using two midpoints) and
# determine which third the target lies in. Recurse on that third.
#
# Time:  O(log₃ n) ≈ O(log n) but with higher constant than binary
# Space: O(1) iterative
# Prerequisite: sorted input
#
# Algorithm:
#   low = 0, high = n - 1
#   while low <= high:
#     mid1 = low + (high - low) / 3
#     mid2 = high - (high - low) / 3
#     if list[mid1] == target: return mid1
#     if list[mid2] == target: return mid2
#     if target < list[mid1]: high = mid1 - 1
#     elif target > list[mid2]: low = mid2 + 1
#     else: low = mid1 + 1; high = mid2 - 1
#   return -1
#
# Useful for unimodal function optimization (finding min/max).

ternary-search:
  inputs:
    - lst: "List(Number)"
    - target: "Number"
  steps:
    - list_new:
        elements: "1 4 7 10 13 16 19 22 25 28"
    # Ternary search: split into thirds, recurse on the relevant third.
    # O(log₃ n). Requires sorted input.
    - racket_filter:
        predicate: "(lambda (x) (equal? x 16))"
