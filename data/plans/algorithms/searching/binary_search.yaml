# prompt: "search for a number in a sorted list using binary search"
#
# Binary Search
# =============
# Search a sorted array by repeatedly dividing the search interval in
# half. Compare the target with the middle element; if not equal,
# eliminate the half where the target cannot lie.
#
# Time:  O(log n)
# Space: O(1) iterative; O(log n) recursive
# Prerequisite: input must be sorted
#
# Algorithm:
#   low = 0, high = n - 1
#   while low <= high:
#     mid = (low + high) / 2
#     if list[mid] == target: return mid
#     elif list[mid] < target: low = mid + 1
#     else: high = mid - 1
#   return -1  # not found

binary-search:
  inputs:
    - lst: "List(Number)"
    - target: "Number"
  steps:
    - list_new:
        elements: "2 5 8 12 16 23 38 56 72 91"
    # Binary search: divide search space in half each step.
    # O(log n). Requires sorted input.
    - racket_filter:
        predicate: "(lambda (x) (equal? x 23))"
