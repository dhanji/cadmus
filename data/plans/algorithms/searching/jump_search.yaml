# prompt: "search for a number using jump search"
#
# Jump Search
# ===========
# For sorted arrays: jump ahead by fixed steps of size √n, then do a
# linear search backward within the block where the target might be.
#
# Time:  O(√n)
# Space: O(1)
# Prerequisite: sorted input
#
# Algorithm:
#   step = floor(√n)
#   prev = 0
#   while list[min(step, n) - 1] < target:
#     prev = step
#     step += floor(√n)
#     if prev >= n: return -1
#   # Linear search from prev to min(step, n)
#   for i in prev..min(step, n):
#     if list[i] == target: return i
#   return -1
#
# Optimal block size is √n. Better than linear, simpler than binary.

jump-search:
  inputs:
    - lst: "List(Number)"
    - target: "Number"
  steps:
    - list_new:
        elements: "1 3 5 7 9 11 13 15 17 19 21 23 25 27 29"
    # Jump search: skip by √n blocks, then linear scan within block.
    # O(√n). Requires sorted input.
    - racket_filter:
        predicate: "(lambda (x) (equal? x 21))"
