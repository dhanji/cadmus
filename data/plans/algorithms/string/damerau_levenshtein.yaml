# Damerau-Levenshtein distance (with transpositions)
# Example: dl("ca", "abc") = 2
# expected: 3

damerau_levenshtein:
  inputs:
    - s1: "String"
    - s2: "String"
  bindings:
    s1: "\"ca\""
    s2: "\"abc\""
  steps:
    - let_bind:
        bindings: "[m (string-length s1)] [n (string-length s2)] [dp (build-vector (+ (string-length s1) 1) (lambda (i) (make-vector (+ (string-length s2) 1) 0)))]"
        body: "(begin (for ([i (in-range (+ m 1))]) (vector-set! (vector-ref dp i) 0 i)) (for ([j (in-range (+ n 1))]) (vector-set! (vector-ref dp 0) j j)) (for* ([i (in-range 1 (+ m 1))] [j (in-range 1 (+ n 1))]) (let ([cost (if (char=? (string-ref s1 (- i 1)) (string-ref s2 (- j 1))) 0 1)]) (vector-set! (vector-ref dp i) j (min (+ (vector-ref (vector-ref dp (- i 1)) j) 1) (+ (vector-ref (vector-ref dp i) (- j 1)) 1) (+ (vector-ref (vector-ref dp (- i 1)) (- j 1)) cost))) (when (and (> i 1) (> j 1) (char=? (string-ref s1 (- i 1)) (string-ref s2 (- j 2))) (char=? (string-ref s1 (- i 2)) (string-ref s2 (- j 1)))) (vector-set! (vector-ref dp i) j (min (vector-ref (vector-ref dp i) j) (+ (vector-ref (vector-ref dp (- i 2)) (- j 2)) cost)))))) (vector-ref (vector-ref dp m) n))"
