# prompt: "sort a list using Tim sort"
#
# Timsort
# =======
# Hybrid sorting algorithm derived from merge sort and insertion sort.
# Designed for real-world data that often has existing order (runs).
# Default sort in Python, Java, and many other languages.
#
# Time:  O(n log n) worst; O(n) best (already sorted)
# Space: O(n)
# Stable: yes
#
# Algorithm:
#   1. Divide array into runs (naturally ordered subsequences)
#      - Minimum run size ≈ 32-64 (tuned for cache performance)
#      - Short runs extended with insertion sort
#   2. Merge runs using a merge stack with invariants:
#      - run[i-2] > run[i-1] + run[i]
#      - run[i-1] > run[i]
#      These ensure balanced merges (galloping mode for unequal runs)
#
# Key insight: real data has "natural runs" — Timsort exploits them.
# Worst case matches merge sort; best case (sorted data) is O(n).

timsort:
  inputs:
    - lst: "List(Number)"
  steps:
    - list_new:
        elements: "5 1 4 2 8 3 7 6 9 10"
    # Timsort: find natural runs, extend with insertion sort, merge.
    # Adaptive: O(n) on nearly-sorted data.
    - sort_list:
        comparator: "<"
