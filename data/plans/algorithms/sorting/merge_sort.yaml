# prompt: "sort a list using merge sort"
#
# Merge Sort
# ==========
# Divide-and-conquer: split the list in half, recursively sort each
# half, then merge the two sorted halves.
#
# Time:  O(n log n) in all cases
# Space: O(n) — requires auxiliary space for merging
# Stable: yes
#
# Algorithm:
#   merge_sort(lst):
#     if length(lst) <= 1: return lst
#     mid = length(lst) / 2
#     left  = merge_sort(lst[0..mid])
#     right = merge_sort(lst[mid..n])
#     return merge(left, right)
#
#   merge(left, right):
#     result = []
#     while left and right:
#       if left[0] <= right[0]:
#         result.append(left.pop(0))
#       else:
#         result.append(right.pop(0))
#     return result + left + right
#
# The recursive split-merge structure is described in comments;
# the plan compiles to a sort primitive.

merge-sort:
  inputs:
    - lst: "List(Number)"
  steps:
    - list_new:
        elements: "38 27 43 3 9 82 10"
    # Merge sort: recursive divide → sort halves → merge.
    # O(n log n) guaranteed. Stable.
    - sort_list:
        comparator: "<"
