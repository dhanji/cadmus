# LRU cache: simulate cache with capacity 2
# Access: 1 2 3 1 â†’ after 3, evict 1; after 1, evict 2
# Final cache contains: (3 1)
# expected: (1 3)

lru_cache_eviction:
  inputs:
    - n: "Number"
  bindings:
    n: "0"
  steps:
    - let_bind:
        bindings: "[capacity 2]"
        body: "(let loop ([ops (list 1 2 3 1)] [cache (list)]) (if (null? ops) cache (let* ([key (car ops)] [cache (remove key cache)] [cache (cons key cache)] [cache (if (> (length cache) capacity) (take cache capacity) cache)]) (loop (cdr ops) cache))))"
